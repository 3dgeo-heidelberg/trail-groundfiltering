{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#welcome-to-the-trail-workshop-on-archaeological-ground-point-filtering-of-lidar-point-clouds","title":"Welcome to the TRAIL Workshop on Archaeological Ground Point Filtering of LiDAR Point Clouds!","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>An important task in the processing of airborne laser scanning data is the derivation of appropriate models (terrain, surface, feature). Setting up such classification and filtering workflows can be time-consuming and prone to information loss, especially in geographically heterogeneous landscapes. AFwizard is an open source Python package designed to improve the productivity of ground point filtering workflows in archaeology and beyond. It provides a Jupyter-based environment for human-in-the-loop, spatially heterogeneous ground point filtering. Through hands-on training, the participants will learn how to study the effects of different algorithm and parameter combinations on digital terrain modelling in a practical and time-saving way. In addition, the AFwizard settings will be tested and analysed using simulated lidar survey scenarios (e.g., airborne, UAV, terrestrial) and point densities. In order to learn how different point cloud properties affect the filtering process, the open source simulator HELIOS++ will be introduced and used together with AFwizard in a hands-on exercise. This will allow for improved filtering of existing data as well as future survey planning.</p>"},{"location":"index.html#what-to-expect","title":"What to expect","text":"<p>In hands-on Jupyter notebooks, we will give:</p> <ul> <li>an introduction to LiDAR ground point filtering using the AFwizard (Adaptive Filtering Wizard)</li> <li>an introduction to HELIOS++ (Heidelberg LiDAR Operations Simulator) to virtually compare different survey scenarios</li> </ul> <p>Important notice</p> <p>As we have only limited time for the workshop, it is essential that you install software and data before the workshop starts! Please follow the instructions on the Installation and download page.</p>"},{"location":"index.html#software-installation-and-data-downloads","title":"Software installation and data downloads","text":"<p>The steps for installation of necessary software and download of scripts and data are documented on the Installation and download page.</p>"},{"location":"index.html#literature-and-references","title":"Literature and References","text":"Journal papers and conferences  Doneus, M., H\u00f6fle, B., Kempf, D., Daskalakis, G. &amp; Shinoto, M. (2022): Human-in-the-loop development of spatially adaptive ground point filtering pipelines \u2014 An archaeological case study. Archaeological Prospection. Vol. 29 (4), pp. 503-524. https://doi.org/10.1002/arp.1873.  <pre><code>@article{Doneus_2022,\n  author  = {Michael Doneus and Bernhard H\\\"ofle and Dominic Kempf and Gwydion Daskalakis and Maria Shinoto},\n  title   = {Human-in-the-loop development of spatially adaptive ground point filtering pipelines {\\textemdash} An archaeological case study},\n  journal = {Archaeological Prospection},\n  year    = {2022},\n  volume  = {29},\n  number  = {4},\n  pages   = {503--524},\n  doi     = {10.1002/arp.1873},\n  url     = {https://doi.org/10.1002/arp.1873}\n  }\n</code></pre>  Winiwarter, L., Esmor\u00eds Pena, A.M., Weiser, H., Anders, K., Mart\u00ednez S\u00e1nchez, J., Searle, M. &amp; H\u00f6fle, B. (2022): Virtual laser scanning with HELIOS++: A novel take on ray tracing-based simulation of topographic full-waveform 3D laser scanning. Remote Sensing of Environment. Vol. 269, pp. 112772. https://doi.org/10.1016/j.rse.2021.112772.  <pre><code>@article{heliosPlusPlus,\n  author = {Lukas Winiwarter and Alberto Manuel {Esmor\u00eds Pena} and Hannah Weiser and Katharina Anders and Jorge {Mart\u00ednez S\u00e1nchez} and Mark Searle and Bernhard H\u00f6fle},\n  title = {Virtual laser scanning with HELIOS++: A novel take on ray tracing-based   simulation of topographic full-waveform 3D laser scanning},\n  journal = {Remote Sensing of Environment},\n  year = {2022},\n  volume = {269},\n  issn = {0034-4257},\n  doi = {https://doi.org/10.1016/j.rse.2021.112772},\n  keywords = {Software, LiDAR simulation, Point cloud, Data generation, Voxel, Vegetation modelling, Diffuse media}\n} \n</code></pre> Software <ul> <li>HELIOS++</li> <li>HELIOS++ Wiki</li> <li>AFwizard</li> <li>AFwizard documentation</li> <li>LAStools</li> <li>Jupyter</li> </ul>"},{"location":"index.html#lecturers","title":"Lecturers","text":"<p>The workshop was prepared by </p> <ul> <li>Michael Doneus (Professor of landscape archaeology, University of Vienna),</li> <li>Hannah Weiser (3DGeo Research Group, Heidelberg University) and </li> <li>Zoran \u010cu\u010dkovi\u0107 (Clermont Auvergne University)</li> </ul>"},{"location":"index.html#acknowledgements","title":"Acknowledgements","text":"<p>This workshop is part of the TRAIL Meeting 2025 under the theme \"Airborne laser scanning for farmed landscapes\". TRAIL (Training and Research in the Archaeological Interpretation of Lidar) was founded to provide opportunities to share expertise and provide training in the archaeological use of LiDAR.</p> <p>The sixth TRAIL Meeting is organized by ZRC SAZU (Slovenia) in partnership with </p> <ul> <li>Historic Environment Scotland (United Kingdom), </li> <li>CNRS (France),</li> <li>University of Clermont Auvergne (France),</li> <li>CLUE+,</li> <li>Vrije Universiteit Amsterdam (The Netherlands), and</li> <li>University of Amsterdam (the Netherlands). </li> </ul> <p>It is financially supported by </p> <ul> <li>ZRC SAZU,</li> <li>Historic Environment Scotland,</li> <li>Aerial Archaeology Research Group,</li> <li>Slovenian Research and Innovation Agency (programme P2-0406) and</li> <li>European Research Council (project STONE, GAP-101089123).</li> </ul>        Organisers and financers of the sixth TRAIL Meeting.      <p>AFwizard was developed by the Scientific Software Center (SSC) of Heidelberg University in the framework of the project Human-in-the-Loop Adaptive Terrain Filtering of 3D Point Clouds for Archaeological Prospection led by Maria Shinoto. The Scientific Software is funded as part of the Excellence Strategy of the German Federal and State Governments.</p> <p>Development of HELIOS++ is led by the 3DGeo Research Group (Prof. Bernhard H\u00f6fle) and the Scientific Software Center (SSC) of Heidelberg University with contributions from several collaborators. HELIOS++ is funded by the German Research Foundation (DFG) in the frame of the Software projects Fostering a community-driven and sustainable HELIOS++ scientific software (528521476) and VirtuaLearn3D (496418931).</p>"},{"location":"helios.html","title":"Intro slides","text":""},{"location":"helios.html#lidar-simulation-with-helios","title":"LiDAR Simulation with HELIOS++","text":""},{"location":"helios.html#journal-papers","title":"Journal Papers","text":"<p>Winiwarter, L., Esmor\u00eds Pena, A.M., Weiser, H., Anders, K., Mart\u00ednez S\u00e1nchez, J., Searle, M. &amp; H\u00f6fle, B. (2022): Virtual laser scanning with HELIOS++: A novel take on ray tracing-based simulation of topographic full-waveform 3D laser scanning. Remote Sensing of Environment. Vol. 269, pp. 112772. https://doi.org/10.1016/j.rse.2021.112772.</p> <pre><code>@article{heliosPlusPlus,\n  author = {Lukas Winiwarter and Alberto Manuel {Esmor\u00eds Pena} and Hannah Weiser and Katharina Anders and Jorge {Mart\u00ednez S\u00e1nchez} and Mark Searle and Bernhard H\u00f6fle},\n  title = {Virtual laser scanning with HELIOS++: A novel take on ray tracing-based   simulation of topographic full-waveform 3D laser scanning},\n  journal = {Remote Sensing of Environment},\n  year = {2022},\n  volume = {269},\n  issn = {0034-4257},\n  doi = {https://doi.org/10.1016/j.rse.2021.112772},\n  keywords = {Software, LiDAR simulation, Point cloud, Data generation, Voxel, Vegetation modelling, Diffuse media}\n}\n</code></pre>"},{"location":"helios.html#links","title":"Links","text":"<ul> <li>HELIOS++</li> <li>HELIOS++ Wiki</li> <li>HELIOS++ Website</li> </ul>"},{"location":"helios_als.html","title":"ALS simulation","text":"<p>LiDAR simulation can be useful for multiple applications:</p> <ul> <li>Acquisition planning</li> <li>Method development and evaluation</li> <li>Training data generation (for machine learning)</li> </ul> <p>In this notebook, we will simulate an airborne LiDAR acquisition, to demonstrate how HELIOS++ can be used for acquisition planning.</p> <p>You can find a comprehensive documentation in the HELIOS Wiki.</p> In\u00a0[1]: Copied! <pre># Imports\nimport os\nimport sys\nfrom pathlib import Path\nimport time\nimport matplotlib.pyplot as plt\nimport matplotlib\nfrom ipywidgets import interact\nimport pyhelios\nfrom pyhelios import SimulationBuilder\nfrom pyhelios.util import flight_planner\nimport helper_funcs\nimport numpy as np\nfrom osgeo import gdal\nimport rasterio as rio\nimport laspy\n</pre> # Imports import os import sys from pathlib import Path import time import matplotlib.pyplot as plt import matplotlib from ipywidgets import interact import pyhelios from pyhelios import SimulationBuilder from pyhelios.util import flight_planner import helper_funcs import numpy as np from osgeo import gdal import rasterio as rio import laspy In\u00a0[2]: Copied! <pre># making sure we have PyQt5/PyQt6 for interactive plotting - this might take a few minutes, be patient\n!{sys.executable} -m pip install PyQt5\n</pre> # making sure we have PyQt5/PyQt6 for interactive plotting - this might take a few minutes, be patient !{sys.executable} -m pip install PyQt5 <pre>Requirement already satisfied: PyQt5 in c:\\users\\3dgeo\\.local\\share\\mamba\\envs\\groundfiltering\\lib\\site-packages (5.15.11)\nRequirement already satisfied: PyQt5-sip&lt;13,&gt;=12.15 in c:\\users\\3dgeo\\.local\\share\\mamba\\envs\\groundfiltering\\lib\\site-packages (from PyQt5) (12.17.1)\nRequirement already satisfied: PyQt5-Qt5&lt;5.16.0,&gt;=5.15.2 in c:\\users\\3dgeo\\.local\\share\\mamba\\envs\\groundfiltering\\lib\\site-packages (from PyQt5) (5.15.2)\n</pre> <p>To execute LAStools commands, we need to provide the LAStools directory. This may be a different location on your computer, so you will have to provide the correct path:</p> In\u00a0[3]: Copied! <pre># configure LAStools root\nlastools_root = \"C:/LAStools\"\n</pre> # configure LAStools root lastools_root = \"C:/LAStools\" <p>Extracting vegetation points</p> <p>Using LAStools \"las2txt\", we convert the LAZ file of the study size to an ASCII file and extract only vegetation points, which have classification values of 0.</p> <p>Note: With the exclamation mark (<code>!</code>), we can issue a shell command and hence run the command line tools of LAStools.</p> In\u00a0[4]: Copied! <pre>Path(\"data/output\").mkdir(parents=True, exist_ok=True)\n!$lastools_root/bin/las2txt64.exe -i data/StA_last.laz -o data/output/StA_last_vegetation.xyz -keep_classification 0 -parse xyz\n</pre> Path(\"data/output\").mkdir(parents=True, exist_ok=True) !$lastools_root/bin/las2txt64.exe -i data/StA_last.laz -o data/output/StA_last_vegetation.xyz -keep_classification 0 -parse xyz <p>Defining scene part files</p> <p>We now define the terrain file (GeoTIFF) and the vegetation point cloud (xyz ASCII), as well as a voxel size for voxelizing the vegetation points.</p> In\u00a0[5]: Copied! <pre>terrain = \"data/StA_last_dtm.tiff\"\nvegetation = \"data/output/StA_last_vegetation.xyz\"\nvoxel_size = 0.5\n\n# Optional: Deriving a spatial subset so simulations run faster. You may set to \"False\" if you have a device with plenty of RAM (&gt;= 64 GB) that can simulate the entire scene.\nspatial_subset = True\n</pre> terrain = \"data/StA_last_dtm.tiff\" vegetation = \"data/output/StA_last_vegetation.xyz\" voxel_size = 0.5  # Optional: Deriving a spatial subset so simulations run faster. You may set to \"False\" if you have a device with plenty of RAM (&gt;= 64 GB) that can simulate the entire scene. spatial_subset = True In\u00a0[6]: Copied! <pre>if spatial_subset:\n    # bounding box of subset\n    bbox = [20103.0, 312815.0, 20596.0, 312410.0]\n\n    # spatial subset of terrain using gdal_translate\n    terrain_sub = \"data/output/StA_last_filtered_sub.tiff\"\n    !gdal_translate -projwin 20103.0 312815.0 20596.0 312410.0 $terrain $terrain_sub\n\n    # spatial subset of vegetation\n    vegetation_sub = \"data/output/StA_last_vegetation_sub.xyz\"\n    vegetation_arr = np.loadtxt(vegetation)\n    idx_sub = (vegetation_arr[:, 0] &gt; bbox[0]) &amp; (vegetation_arr[:, 0] &lt; bbox[2]) &amp; (vegetation_arr[:, 1] &gt; bbox[3]) &amp; (vegetation_arr[:, 1] &lt; bbox[1])\n    vegetation_arr_sub = vegetation_arr[idx_sub, :]\n    np.savetxt(vegetation_sub, vegetation_arr_sub, fmt=\"%.6f\")\n\n    terrain = terrain_sub\n    vegetation = vegetation_sub\n</pre> if spatial_subset:     # bounding box of subset     bbox = [20103.0, 312815.0, 20596.0, 312410.0]      # spatial subset of terrain using gdal_translate     terrain_sub = \"data/output/StA_last_filtered_sub.tiff\"     !gdal_translate -projwin 20103.0 312815.0 20596.0 312410.0 $terrain $terrain_sub      # spatial subset of vegetation     vegetation_sub = \"data/output/StA_last_vegetation_sub.xyz\"     vegetation_arr = np.loadtxt(vegetation)     idx_sub = (vegetation_arr[:, 0] &gt; bbox[0]) &amp; (vegetation_arr[:, 0] &lt; bbox[2]) &amp; (vegetation_arr[:, 1] &gt; bbox[3]) &amp; (vegetation_arr[:, 1] &lt; bbox[1])     vegetation_arr_sub = vegetation_arr[idx_sub, :]     np.savetxt(vegetation_sub, vegetation_arr_sub, fmt=\"%.6f\")      terrain = terrain_sub     vegetation = vegetation_sub <pre>Input file size is 801, 751\n0...10...20...30...40...50...60...70...80...90...100 - done.\n</pre> <p>Writing the scene</p> <p>HELIOS++ uses XML files for configuring scanners, platforms, surveys and scenes. Below, we write such an XML file and fill in the values we defined before (<code>terrain</code>, <code>vegetation</code>, <code>voxel_size</code>). Note how each scene part is embedded in a <code>&lt;part&gt;</code> tag and uses a different \"loader\" <code>filter</code> depending on the file format.</p> In\u00a0[7]: Copied! <pre># Writing the scene XML file\nscene_content = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;document&gt;\n    &lt;scene id=\"helios_scene\" name=\"HELIOS scene\"&gt;\n        \n        &lt;part&gt;\n            &lt;filter type=\"geotiffloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"{terrain}\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"xyzloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"{vegetation}\" /&gt;\n                &lt;param type=\"string\" key=\"separator\" value=\" \" /&gt;\n                &lt;param type=\"double\" key=\"voxelSize\" value=\"{voxel_size}\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n    &lt;/scene&gt;\n&lt;/document&gt;\n\"\"\"\n</pre> # Writing the scene XML file scene_content = f\"\"\"  \"\"\" In\u00a0[8]: Copied! <pre># save scene file to the current directory\nscene_file = \"StA_helios_scene.xml\"\nwith open(scene_file, \"w\") as f:\n    f.write(scene_content)\n</pre> # save scene file to the current directory scene_file = \"StA_helios_scene.xml\" with open(scene_file, \"w\") as f:     f.write(scene_content) In\u00a0[9]: Copied! <pre>platform = \"sr22\"\nscanner = \"riegl_lms-q560\"\n</pre> platform = \"sr22\" scanner = \"riegl_lms-q560\" <p>First, we want to mimic the original acquisition.</p> <p>Waypoints (trajectory)</p> <p>For simplification, we will include only two flight passes, which you can define interactively below. A plot will open in a new window, where you can select the waypoints by clicking on the DEM image.</p> In\u00a0[10]: Copied! <pre>n_pos = 4\ndtm, tf, bounds, origin_left, origin_bottom, origin_right, origin_top = helper_funcs.read_raster(terrain)\n</pre> n_pos = 4 dtm, tf, bounds, origin_left, origin_bottom, origin_right, origin_top = helper_funcs.read_raster(terrain) In\u00a0[11]: Copied! <pre>%matplotlib qt\nwaypoints = helper_funcs.interactive_flight_trajectory(dtm, tf, n_pos=n_pos)\nwaypoints = np.array(waypoints)\n</pre> %matplotlib qt waypoints = helper_funcs.interactive_flight_trajectory(dtm, tf, n_pos=n_pos) waypoints = np.array(waypoints) <pre>Ignoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n</pre> <pre>You have chosen your flight lines.\n[[20175.89, 312521.69], [20471.51, 312780.97], [20568.74, 312686.69], [20256.42, 312450.97]]\n</pre> <p>Let's plot the chosen configured flight paths on top of the terrain.</p> In\u00a0[12]: Copied! <pre>%matplotlib inline\nplt.imshow(dtm, cmap=\"terrain\", extent=[origin_left, origin_right, origin_bottom, origin_top])\nplt.plot(waypoints[:, 0], waypoints[:, 1])\nplt.show()\n</pre> %matplotlib inline plt.imshow(dtm, cmap=\"terrain\", extent=[origin_left, origin_right, origin_bottom, origin_top]) plt.plot(waypoints[:, 0], waypoints[:, 1]) plt.show() <p>Acquisition settings</p> <p>Now we configure the acquisition settings.</p> In\u00a0[13]: Copied! <pre># compute mean DTM height\ndtm_height = np.mean(dtm)\n\npulse_freq = 100_000\nscan_freq = 80\nflight_v = 60\nalt = dtm_height + 1000  # summing up mean DTM height and desired height above ground level (AGL)\nscan_angle = 45\n</pre> # compute mean DTM height dtm_height = np.mean(dtm)  pulse_freq = 100_000 scan_freq = 80 flight_v = 60 alt = dtm_height + 1000  # summing up mean DTM height and desired height above ground level (AGL) scan_angle = 45 <p>Writing the survey file</p> <p>Finally, we can write the survey file, which is also an XML file. You can find further examples in the HELIOS++ demo data folder.</p> In\u00a0[14]: Copied! <pre>legs = \"\"\nactive = True\nfor i in range(n_pos):\n    if i % 2 == 0:\n        active = \"true\"\n    else:\n        active = \"false\"\n    \n    x, y = waypoints[i]\n    \n    legs += f'''\n    &lt;leg&gt;\n            &lt;platformSettings x=\"{x}\" y=\"{y}\" template=\"platform_als\"/&gt;\n            &lt;scannerSettings template=\"scanner_als\" active=\"{active}\"/&gt;\n    &lt;/leg&gt;'''\n</pre> legs = \"\" active = True for i in range(n_pos):     if i % 2 == 0:         active = \"true\"     else:         active = \"false\"          x, y = waypoints[i]          legs += f'''      ''' <p>Note how the survey below links to the <code>scanner</code> and <code>scene</code> that we defined earlier.</p> In\u00a0[15]: Copied! <pre>survey_content = f'''&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;document&gt;\n    &lt;platformSettings id=\"platform_als\" movePerSec_m=\"{flight_v}\" z=\"{alt}\" /&gt;\n    &lt;scannerSettings active=\"true\" id=\"scanner_als\" pulseFreq_hz=\"{pulse_freq}\" scanAngle_deg=\"{scan_angle}\" scanFreq_hz=\"{scan_freq}\" trajectoryTimeInterval_s=\"0.01\"/&gt;\n    &lt;survey name=\"als_survey\" platform=\"data/platforms.xml#{platform}\" scanner=\"data/scanners_als.xml#{scanner}\" scene=\"{scene_file}#helios_scene\"&gt;\n    &lt;FWFSettings beamSampleQuality=\"3\" winSize_ns=\"1.5\"/&gt;\n    {legs}\n    &lt;/survey&gt;\n&lt;/document&gt;\n''' \n</pre> survey_content = f'''      {legs}       '''  In\u00a0[16]: Copied! <pre>survey_file = \"als_StA_survey.xml\"\nwith open(survey_file, 'w') as f:\n    f.write(survey_content)\n</pre> survey_file = \"als_StA_survey.xml\" with open(survey_file, 'w') as f:     f.write(survey_content) In\u00a0[17]: Copied! <pre>pyhelios.loggingDefault()\nsimB = SimulationBuilder(str(survey_file), ['assets/'], 'helios_output/')\nsimB.setLasOutput(True)\nsimB.setZipOutput(True)\n\n# build the simulation\nsim = simB.build()\n\n# Start the simulation.\nstart_time = time.time()\nsim.start()\n\nif sim.isStarted():\n    print(f'Simulation has started!\\nSurvey Name: {sim.sim.getSurvey().name}\\n{sim.sim.getScanner().toString()}')\n\nwhile sim.isRunning():\n    duration = time.time()-start_time\n    mins = duration // 60\n    secs = duration % 60\n    print('\\r'+f'Simulation has been running for {int(mins)} min and {int(secs)} sec. Please wait.', end='')\n    time.sleep(1)\n\nif sim.isFinished():\n    print('\\n'+'Simulation has finished!')\n\noutput = sim.join()\nmeas, traj = pyhelios.outputToNumpy(output)\n</pre> pyhelios.loggingDefault() simB = SimulationBuilder(str(survey_file), ['assets/'], 'helios_output/') simB.setLasOutput(True) simB.setZipOutput(True)  # build the simulation sim = simB.build()  # Start the simulation. start_time = time.time() sim.start()  if sim.isStarted():     print(f'Simulation has started!\\nSurvey Name: {sim.sim.getSurvey().name}\\n{sim.sim.getScanner().toString()}')  while sim.isRunning():     duration = time.time()-start_time     mins = duration // 60     secs = duration % 60     print('\\r'+f'Simulation has been running for {int(mins)} min and {int(secs)} sec. Please wait.', end='')     time.sleep(1)  if sim.isFinished():     print('\\n'+'Simulation has finished!')  output = sim.join() meas, traj = pyhelios.outputToNumpy(output) <pre>SimulationBuilder is building simulation ...\nSimulationBuilder built simulation in 31.579064099998504 seconds\nSimulation has started!\nSurvey Name: als_survey\nScanner: riegl_lms-q560\nDevice[0]: riegl_lms-q560\n\tAverage Power: 4 W\n\tBeam Divergence: 0.5 mrad\n\tWavelength: 1064 nm\n\tVisibility: 23 km\n\nSimulation has been running for 0 min and 1 sec. Please wait.\nSimulation has finished!\n</pre> In\u00a0[18]: Copied! <pre># Load the real-world data\nlas = laspy.read(\"data/StA_last.laz\")\nref = np.array([las.x, las.y, las.z]).T\n</pre> # Load the real-world data las = laspy.read(\"data/StA_last.laz\") ref = np.array([las.x, las.y, las.z]).T In\u00a0[19]: Copied! <pre>%matplotlib inline\n# plotting a cross section\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(20, 8))\n\nfor pc, ax, title in zip([meas, ref], [ax1, ax2], [\"Simulated\", \"Real-world\"]):\n    if spatial_subset:\n        idx = (pc[:, 0] &gt; bbox[0]) &amp; (pc[:, 0] &lt; bbox[2])\n        pc = pc[idx, :]\n    idx = (pc[:, 1] &gt; 312580) &amp; (pc[:, 1] &lt; 312590)\n    ax.scatter(pc[idx, 0], pc[idx, 2], c=pc[idx, 2], s=0.02, cmap=\"terrain\")\n    ax.set_xlabel(\"X [m]\")\n    ax.set_ylabel(\"Z [m]\")\n    ax.set_title(title)\n    if spatial_subset:\n        ax.set_xlim(xmin=20100, xmax=20600)\n\nplt.tight_layout()\nplt.show()\n</pre> %matplotlib inline # plotting a cross section fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(20, 8))  for pc, ax, title in zip([meas, ref], [ax1, ax2], [\"Simulated\", \"Real-world\"]):     if spatial_subset:         idx = (pc[:, 0] &gt; bbox[0]) &amp; (pc[:, 0] &lt; bbox[2])         pc = pc[idx, :]     idx = (pc[:, 1] &gt; 312580) &amp; (pc[:, 1] &lt; 312590)     ax.scatter(pc[idx, 0], pc[idx, 2], c=pc[idx, 2], s=0.02, cmap=\"terrain\")     ax.set_xlabel(\"X [m]\")     ax.set_ylabel(\"Z [m]\")     ax.set_title(title)     if spatial_subset:         ax.set_xlim(xmin=20100, xmax=20600)  plt.tight_layout() plt.show() In\u00a0[20]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(20, 10))\nmeas_ground = meas[meas[:, 14] == 0, :]\nref_ground = ref[las[\"classification\"] == 2, :]\n\nfor pc, ax in zip([meas_ground, ref_ground], [ax1, ax2]):\n    ax.scatter(pc[::2, 0], pc[::2, 1], c=pc[::2, 2], s=0.02, cmap=\"terrain\")  # only plot every 2nd point so it is faster\n    ax.set_xlabel(\"X [m]\")\n    ax.set_ylabel(\"Y [m]\")\n    if spatial_subset:\n        ax.set_xlim(bbox[0], bbox[2])\n        ax.set_ylim(bbox[1], bbox[3])\n    ax.set_aspect(\"equal\")\n    \nax1.set_title(\"Simulated\")\nax2.set_title(\"Real-World\")\nplt.tight_layout()\nplt.show()\n</pre> fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(20, 10)) meas_ground = meas[meas[:, 14] == 0, :] ref_ground = ref[las[\"classification\"] == 2, :]  for pc, ax in zip([meas_ground, ref_ground], [ax1, ax2]):     ax.scatter(pc[::2, 0], pc[::2, 1], c=pc[::2, 2], s=0.02, cmap=\"terrain\")  # only plot every 2nd point so it is faster     ax.set_xlabel(\"X [m]\")     ax.set_ylabel(\"Y [m]\")     if spatial_subset:         ax.set_xlim(bbox[0], bbox[2])         ax.set_ylim(bbox[1], bbox[3])     ax.set_aspect(\"equal\")      ax1.set_title(\"Simulated\") ax2.set_title(\"Real-World\") plt.tight_layout() plt.show() <p>You should see clear differences in point density and ground coverage. You may also see where flight strips overlap and where they don't.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"helios_als.html#an-introduction-to-lidar-simulation-with-helios","title":"An Introduction to LiDAR Simulation with HELIOS++\u00b6","text":"<p>I: Airborne laser scanning (ALS)</p>"},{"location":"helios_als.html#1-the-virtual-scene","title":"1. The virtual scene\u00b6","text":"<p>The first component of a simulation is the 3D input scene. HELIOS++ supports loading different file format, including Wavefront OBJ triangle meshes, GeoTIFF rasters or XYZ point clouds, which will be converted to voxel models. In this tutorial, we will use GeoTIFF for loading terrain and XYZ files for loading voxelized vegetation.</p>"},{"location":"helios_als.html#2-selection-of-platform-and-scanner","title":"2. Selection of platform and scanner\u00b6","text":"<p>In this scenario, we will select an airborne platform (\"Cirrus SR-22\"), similar to the original acquisition. As scanner, we choose the \"RIEGL LMS-Q560\".</p> <p>Feel free to try out other scanners in python/pyhelios/data/scanners_als.xml but please notice that different scanner types require different survey specifications.</p>"},{"location":"helios_als.html#3-specification-of-the-survey","title":"3. Specification of the survey\u00b6","text":""},{"location":"helios_als.html#4-running-the-simulation","title":"4. Running the simulation\u00b6","text":""},{"location":"helios_als.html#5-comparison-to-the-real-data","title":"5. Comparison to the real data\u00b6","text":"<p>Using side views and top views, we visualise the simulated and real-world data to compare them.</p>"},{"location":"helios_for_afwizard.html","title":"Assessing AFwizard pipelines with LiDAR simulation","text":"<p>We have prepared an ALS scenario for virtual simulation over the 2nd study site (Monastery St. Anna &amp; Scharfeneck Ruin, AT). We will run the simulation, which will give us a point cloud with a ground truth classification of terrain and vegetation. We can then run AFwizard with the pipeline we built before and compare the AFwizard classification with our \"virtual ground truth\" to evaluate the suitability of our pipeline. As such, we do not have to rely on visual expert assessment for judging our filtering pipeline but can actually quantify the filtering quality.</p> In\u00a0[1]: Copied! <pre># Imports\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport pyhelios\nfrom pyhelios import SimulationBuilder\nfrom pyhelios.util import flight_planner\nimport helper_funcs\nimport numpy as np\nimport laspy\nimport scipy.spatial\n</pre> # Imports from pathlib import Path import matplotlib.pyplot as plt import matplotlib import pyhelios from pyhelios import SimulationBuilder from pyhelios.util import flight_planner import helper_funcs import numpy as np import laspy import scipy.spatial <p>To execute LAStools commands, we need to provide the LAStools directory. This may be a different location on your computer, so you will have to provide the correct path:</p> In\u00a0[2]: Copied! <pre># configure LAStools root\nlastools_root = \"C:/LAStools\"\n</pre> # configure LAStools root lastools_root = \"C:/LAStools\" In\u00a0[3]: Copied! <pre># making sure that data/output exists before execution\nPath(\"data/output\").mkdir(parents=True, exist_ok=True)\n# extracting vegetation points using LAStools and write as XYZ ASCII (text) file\n!$lastools_root/bin/las2txt64.exe -i data/StA_last.laz -o data/output/StA_last_vegetation.xyz -keep_classification 0 -parse xyz\n</pre> # making sure that data/output exists before execution Path(\"data/output\").mkdir(parents=True, exist_ok=True) # extracting vegetation points using LAStools and write as XYZ ASCII (text) file !$lastools_root/bin/las2txt64.exe -i data/StA_last.laz -o data/output/StA_last_vegetation.xyz -keep_classification 0 -parse xyz <p>Writing the scene</p> <p>HELIOS++ uses XML files for configuring scanners, platforms, surveys and scenes. Below, we write such an XML file and fill in the values we defined before (<code>terrain</code>, <code>vegetation</code>, <code>voxel_size</code>). Note how each scene part is embedded in a <code>&lt;part&gt;</code> tag and uses a different \"loader\" <code>filter</code> depending on the file format.</p> In\u00a0[4]: Copied! <pre>terrain = \"data/StA_last_dtm.tiff\"\nvegetation = \"data/output/StA_last_vegetation.xyz\"\nvoxel_size = 0.5\n</pre> terrain = \"data/StA_last_dtm.tiff\" vegetation = \"data/output/StA_last_vegetation.xyz\" voxel_size = 0.5 In\u00a0[5]: Copied! <pre># Writing the scene XML file\nscene_content = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;document&gt;\n    &lt;scene id=\"helios_scene\" name=\"HELIOS scene\"&gt;\n        \n        &lt;part&gt;\n            &lt;filter type=\"geotiffloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"{terrain}\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"xyzloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"{vegetation}\" /&gt;\n                &lt;param type=\"string\" key=\"separator\" value=\" \" /&gt;\n                &lt;param type=\"double\" key=\"voxelSize\" value=\"{voxel_size}\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n    &lt;/scene&gt;\n&lt;/document&gt;\n\"\"\"\n</pre> # Writing the scene XML file scene_content = f\"\"\"  \"\"\" In\u00a0[6]: Copied! <pre># save scene file to the current directory\nscene_file = \"StA_helios_scene.xml\"\nwith open(scene_file, \"w\") as f:\n    f.write(scene_content)\n</pre> # save scene file to the current directory scene_file = \"StA_helios_scene.xml\" with open(scene_file, \"w\") as f:     f.write(scene_content) <p>Writing the survey</p> <p>A pre-defined survey with all relevant parameters is given below. We only enter the scene file from our Python variable.</p> In\u00a0[7]: Copied! <pre>from pyhelios.util import flight_planner\nbbox = [19800, 312150, 20600, 312900]\nwaypoints, centre, distance = flight_planner.compute_flight_lines(bounding_box=bbox,\n                                               spacing=260,\n                                               rotate_deg=-10,\n                                               flight_pattern=\"parallel\")\n# add slight random noise to each waypoint, so they are not perfectly parallel\npos_noise = np.random.uniform(-10, 10, waypoints.shape)\nwaypoints += pos_noise\n</pre> from pyhelios.util import flight_planner bbox = [19800, 312150, 20600, 312900] waypoints, centre, distance = flight_planner.compute_flight_lines(bounding_box=bbox,                                                spacing=260,                                                rotate_deg=-10,                                                flight_pattern=\"parallel\") # add slight random noise to each waypoint, so they are not perfectly parallel pos_noise = np.random.uniform(-10, 10, waypoints.shape) waypoints += pos_noise In\u00a0[8]: Copied! <pre>dtm, tf, bounds, origin_left, origin_bottom, origin_right, origin_top = helper_funcs.read_raster(terrain)\nplt.imshow(dtm, cmap=\"terrain\", extent=[origin_left, origin_right, origin_bottom, origin_top])\nplt.plot(waypoints[:, 0], waypoints[:, 1])\nplt.show()\n</pre> dtm, tf, bounds, origin_left, origin_bottom, origin_right, origin_top = helper_funcs.read_raster(terrain) plt.imshow(dtm, cmap=\"terrain\", extent=[origin_left, origin_right, origin_bottom, origin_top]) plt.plot(waypoints[:, 0], waypoints[:, 1]) plt.show() In\u00a0[9]: Copied! <pre>legs = flight_planner.write_legs(waypoints, altitude=1288, template_id=\"scanner_als\", speed=\"50\")\n</pre> legs = flight_planner.write_legs(waypoints, altitude=1288, template_id=\"scanner_als\", speed=\"50\") In\u00a0[10]: Copied! <pre># insert scene XML string and writing part below; see below as template\nsurvey_content = f'''&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;document&gt;\n    &lt;platformSettings id=\"platform_als\" movePerSec_m=\"50\" /&gt;\n    &lt;scannerSettings active=\"true\" id=\"scanner_als\" pulseFreq_hz=\"100000\" scanAngle_deg=\"45\" scanFreq_hz=\"60\" trajectoryTimeInterval_s=\"0.01\"/&gt;\n    &lt;survey name=\"als_survey_StA\" platform=\"data/platforms.xml#sr22\" scanner=\"data/scanners_als.xml#riegl_lms-q560\" scene=\"{scene_file}#helios_scene\"&gt;\n    &lt;FWFSettings beamSampleQuality=\"5\" winSize_ns=\"1.5\"/&gt;\n    {legs}\n    &lt;/survey&gt;\n&lt;/document&gt;\n''' \n</pre> # insert scene XML string and writing part below; see below as template survey_content = f'''      {legs}       '''  In\u00a0[11]: Copied! <pre>survey_file = \"als_survey_StA.xml\"\nwith open(survey_file, 'w') as f:\n    f.write(survey_content)\n</pre> survey_file = \"als_survey_StA.xml\" with open(survey_file, 'w') as f:     f.write(survey_content) <p>Executing HELIOS++</p> <p>Now we are all set to execute HELIOS++. Since AFwizard takes a LAZ file as input, we run HELIOS++ in command line mode (rather than using the Python bindings) and then work with the written LAZ files.</p> In\u00a0[12]: Copied! <pre>!helios $survey_file --lasOutput --zipOutput --output helios_output -q\n</pre> !helios $survey_file --lasOutput --zipOutput --output helios_output -q In\u00a0[13]: Copied! <pre>outfolder = helper_funcs.find_playback_dir(survey_file, output_folder=\"helios_output\")\n</pre> outfolder = helper_funcs.find_playback_dir(survey_file, output_folder=\"helios_output\") In\u00a0[14]: Copied! <pre>!$lastools_root/bin/lasmerge64.exe -i $outfolder/*.laz -o data/output/helios_als_StA.laz -faf\n</pre> !$lastools_root/bin/lasmerge64.exe -i $outfolder/*.laz -o data/output/helios_als_StA.laz -faf In\u00a0[15]: Copied! <pre>!$lastools_root/bin/lasinfo64.exe data/output/helios_als_StA.laz\n</pre> !$lastools_root/bin/lasinfo64.exe data/output/helios_als_StA.laz <pre>lasinfo (220107) report for 'data/output/helios_als_StA.laz'\nreporting all LAS header entries:\n  file signature:             'LASF'\n  file source ID:             0\n  global_encoding:            0\n  project ID GUID data 1-4:   00000000-0000-0000-0000-000000000000\n  version major.minor:        1.4\n  system identifier:          'LAStools (c) by rapidlasso GmbH'\n  generating software:        'lasmerge64 (version 220107)'\n  file creation day/year:     301/2025\n  header size:                375\n  offset to point data:       1197\n  number var. length records: 1\n  point data format:          6\n  point data record length:   74\n  number of point records:    0\n  number of points by return: 0 0 0 0 0\n  scale factor x y z:         0.0001 0.0001 0.0001\n  offset x y z:               20199.873999999999796 312525.01500000001397 296.580997741699207\n  min x y z:                  19799.3195 312149.6091 238.2840\n  max x y z:                  20600.4089 312900.4420 354.9931\n  start of waveform data packet record: 0\n  start of first extended variable length record: 0\n  number of extended_variable length records: 0\n  extended number of point records: 3902605\n  extended number of points by return: 1714247 1237603 624244 238340 69379 15541 2768 423 55 5 0 0 0 0 0\nvariable length header record 1 of 1:\n  reserved             0\n  user ID              'LASF_Spec'\n  record ID            4\n  length after header  768\n  description          'by LAStools of rapidlasso GmbH'\n    Extra Byte Descriptions\n      data type: 10 (double), name \"echo_width\", description: \"Helios++ echo width\", scale: 1 (not set), offset: 0 (not set)\n      data type: 6 (long), name \"fullwaveIndex\", description: \"Helios++ fullwave index\", scale: 1 (not set), offset: 0 (not set)\n      data type: 6 (long), name \"hitObjectId\", description: \"Helios++ hit object ID\", scale: 1 (not set), offset: 0 (not set)\n      data type: 10 (double), name \"heliosAmplitude\", description: \"Helios++ Amplitude\", scale: 1 (not set), offset: 0 (not set)\nLASzip compression (version 3.4r3 c3 50000): POINT14 3 BYTE14 3\nreporting minimum and maximum for all LAS point record entries ...\n  X            -4005545    4005349\n  Y            -3754059    3754270\n  Z             -582970     584121\n  intensity           0         67\n  return_number       1          7\n  number_of_returns   1          7\n  edge_of_flight_line 0          0\n  scan_direction_flag 0          0\n  classification      0          0\n  scan_angle_rank     0          0\n  user_data           0          0\n  point_source_ID     1          3\n  gps_time 300051.012500 300109.585430\n  extended_return_number          1     10\n  extended_number_of_returns      1     10\n  extended_classification         0      0\n  extended_scan_angle             0      0\n  extended_scanner_channel        0      0\n  attribute0          0          0  ('echo_width')\n  attribute1        417 2.41133e+06  ('fullwaveIndex')\n  attribute2          0          1  ('hitObjectId')\n  attribute3    6.68315    1035.16  ('heliosAmplitude')\nnumber of first returns:        1714247\nnumber of intermediate returns: 950755\nnumber of last returns:         1714247\nnumber of single returns:       476644\noverview over extended number of returns of given pulse: 476644 1226718 1157712 675844 269190 76638 16415 2944 450 50 0 0 0 0 0\nhistogram of classification of points:\n         3902605  never classified (0)\n</pre> <p>In this LAStools window, we can see that the <code>hitObjectId</code>, which holds the information whether the point has been reflected from the ground (0) or from vegetation (1) is encoded in \"attribute2\". So on the following <code>las2las</code> commmand, we will drop all points with attribute <code>2</code> larger than <code>0</code> from the point cloud and write the result to a new file.</p> In\u00a0[16]: Copied! <pre>!$lastools_root/bin/las2las64.exe -i data/output/helios_als_StA.laz -o data/output/helios_als_StA_ground_gt.laz -drop_attribute_above 2 0\n</pre> !$lastools_root/bin/las2las64.exe -i data/output/helios_als_StA.laz -o data/output/helios_als_StA_ground_gt.laz -drop_attribute_above 2 0 <p>Now we run AFwizard on the unfiltered point cloud with our previously created filtering pipeline.</p> In\u00a0[17]: Copied! <pre># run AFwizard on simulated point cloud\n!afwizard --dataset=data/output/helios_als_StA.laz --dataset-crs=EPSG:31256 --segmentation=data/StA_segments_assigned.geojson --segmentation-crs=EPSG:31256 --output-dir=data/output --library filters --lastools-dir=$lastools_root\n</pre> # run AFwizard on simulated point cloud !afwizard --dataset=data/output/helios_als_StA.laz --dataset-crs=EPSG:31256 --segmentation=data/StA_segments_assigned.geojson --segmentation-crs=EPSG:31256 --output-dir=data/output --library filters --lastools-dir=$lastools_root <pre>C:\\Users\\3DGeo\\.local\\share\\mamba\\envs\\groundfiltering\\Lib\\site-packages\\osgeo\\gdal.py:311: FutureWarning: Neither gdal.UseExceptions() nor gdal.DontUseExceptions() has been explicitly called. In GDAL 4.0, exceptions will be enabled by default.\n  warnings.warn(\n</pre> <p>We will find this point cloud in the <code>output</code> folder as <code>helios_als_StA_filtered.las</code> and will run a similar command on it, but this time using the <code>classification</code> value and keeping only the value <code>2</code>.</p> In\u00a0[18]: Copied! <pre>!$lastools_root/bin/las2las64.exe -i data/output/helios_als_StA_filtered.las -o data/output/helios_als_StA_ground_afwizard.laz -keep_classification 2\n</pre> !$lastools_root/bin/las2las64.exe -i data/output/helios_als_StA_filtered.las -o data/output/helios_als_StA_ground_afwizard.laz -keep_classification 2 In\u00a0[19]: Copied! <pre>output_afwizard = \"data/output/helios_als_StA_ground_afwizard.laz\"\noutput_gt = \"data/output/helios_als_StA_ground_gt.laz\"\n</pre> output_afwizard = \"data/output/helios_als_StA_ground_afwizard.laz\" output_gt = \"data/output/helios_als_StA_ground_gt.laz\" In\u00a0[20]: Copied! <pre># read with laspy\nlas = laspy.read(output_afwizard)\npc_afwizard = np.array([las.x, las.y, las.z]).T\nlas = laspy.read(output_gt)\npc_gt = np.array([las.x, las.y, las.z]).T\n</pre> # read with laspy las = laspy.read(output_afwizard) pc_afwizard = np.array([las.x, las.y, las.z]).T las = laspy.read(output_gt) pc_gt = np.array([las.x, las.y, las.z]).T In\u00a0[21]: Copied! <pre># difference in number of points\ndiff = pc_gt.shape[0] - pc_afwizard.shape[0]\nprint(f\"Difference in number of points: {diff} (= {diff/pc_gt.shape[0] * 100:.1f}%)\")\n</pre> # difference in number of points diff = pc_gt.shape[0] - pc_afwizard.shape[0] print(f\"Difference in number of points: {diff} (= {diff/pc_gt.shape[0] * 100:.1f}%)\") <pre>Difference in number of points: 19590 (= 1.8%)\n</pre> In\u00a0[22]: Copied! <pre># calculate overlap ratio\ndef overlap_ratio(pc1, pc2, inlier_threshold=0.001):\n    # get distance to closest point\n    kdtree = scipy.spatial.KDTree(pc1)\n    d, i = kdtree.query(pc2, k=1)\n    # evaluate whether inlier or not\n    inlier_count = np.sum(d &lt; inlier_threshold)\n    # compute overlap_ratio\n    overlap_ratio = inlier_count / pc2.shape[0]\n    \n    outliers = pc2[d &gt; inlier_threshold]\n    \n    return overlap_ratio, outliers\n</pre> # calculate overlap ratio def overlap_ratio(pc1, pc2, inlier_threshold=0.001):     # get distance to closest point     kdtree = scipy.spatial.KDTree(pc1)     d, i = kdtree.query(pc2, k=1)     # evaluate whether inlier or not     inlier_count = np.sum(d &lt; inlier_threshold)     # compute overlap_ratio     overlap_ratio = inlier_count / pc2.shape[0]          outliers = pc2[d &gt; inlier_threshold]          return overlap_ratio, outliers In\u00a0[23]: Copied! <pre>o_ratio, outliers = overlap_ratio(pc_afwizard, pc_gt, inlier_threshold=0.01)\nprint(f\"Overlap ratio for threshold = 0.01: {o_ratio*100:.2f}%\")\n</pre> o_ratio, outliers = overlap_ratio(pc_afwizard, pc_gt, inlier_threshold=0.01) print(f\"Overlap ratio for threshold = 0.01: {o_ratio*100:.2f}%\") <pre>Overlap ratio for threshold = 0.01: 98.15%\n</pre> In\u00a0[24]: Copied! <pre># visualize side by side\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 7))\n\nfor pc, ax, title in zip([pc_gt, pc_afwizard], [ax1, ax2], [\"Ground truth\", \"AFwizard\"]):\n    ax.scatter(pc[:, 0], pc[:, 1], c=pc[:, 2], s=0.02, cmap=\"terrain\")\n    ax.set_xlabel(\"X [m]\")\n    ax.set_ylabel(\"Y [m]\")\n    ax.axis('equal')\n    ax.set_title(title)\n\nax2.scatter(outliers[:, 0], outliers[:, 1], c=\"black\", s=0.05)\nplt.tight_layout()\nplt.show()\n</pre> # visualize side by side fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 7))  for pc, ax, title in zip([pc_gt, pc_afwizard], [ax1, ax2], [\"Ground truth\", \"AFwizard\"]):     ax.scatter(pc[:, 0], pc[:, 1], c=pc[:, 2], s=0.02, cmap=\"terrain\")     ax.set_xlabel(\"X [m]\")     ax.set_ylabel(\"Y [m]\")     ax.axis('equal')     ax.set_title(title)  ax2.scatter(outliers[:, 0], outliers[:, 1], c=\"black\", s=0.05) plt.tight_layout() plt.show() <p>The black points on the right show which points were not correctly filtered by the AFwizard pipeline.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"helios_for_afwizard.html#an-introduction-to-lidar-simulation-with-helios","title":"An Introduction to LiDAR Simulation with HELIOS++\u00b6","text":"<p>III: Evaluate AFwizard-based ground filtering with HELIOS++</p> <p>LiDAR simulation can be useful for multiple applications:</p> <ul> <li>Acquisition planning</li> <li>Method development and evaluation</li> <li>Training data generation (for machine learning)</li> </ul> <p>In this notebook, we will use HELIOS++ for method evaluation, i.e., to assess the groundfiltering results of AFwizard with virtual \"ground truth\".</p>"},{"location":"helios_for_afwizard.html#1-running-the-simulation","title":"1. Running the simulation\u00b6","text":"<p>Preparing the scene part files</p> <p>We first have to create a few files which we need as input to our simulation, namely:</p> <ul> <li>the terrain (as .tif GeoTIFF)</li> <li>the vegetation cover (as .xyz ASCII), which HELIOS++ will internally transform into a voxel model</li> </ul>"},{"location":"helios_for_afwizard.html#3-running-the-afwizard-pipeline","title":"3. Running the AFwizard pipeline\u00b6","text":"<p>HELIOS++ writes one file per flight line (\"leg\"). We first merge the flight lines to a single LAZ file and then use this LAZ file as input to AFwizard. We furthermore extract the simulated ground points by selecting the points with \"hitObjectId\" = 0. These will serve as our reference for AFwizard.</p>"},{"location":"helios_for_afwizard.html#4-comparison-of-afwizard-output-with-ground-truth","title":"4. Comparison of AFwizard output with ground truth\u00b6","text":""},{"location":"helios_uls.html","title":"ULS simulation","text":"<p>LiDAR simulation can be useful for multiple applications:</p> <ul> <li>Acquisition planning</li> <li>Method development and evaluation</li> <li>Training data generation (for machine learning)</li> </ul> <p>In this notebook, we will simulate a UAV-borne LiDAR acquisition to demonstrate how HELIOS++ can be used for acquisition planning.</p> In\u00a0[1]: Copied! <pre># Imports\nimport os\nfrom pathlib import Path\nimport time\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport pyhelios\nfrom pyhelios import SimulationBuilder\nfrom pyhelios.util import flight_planner\nimport helper_funcs\nimport numpy as np\nfrom osgeo import gdal\nimport rasterio as rio\nimport laspy\n</pre> # Imports import os from pathlib import Path import time import matplotlib.pyplot as plt import matplotlib import pyhelios from pyhelios import SimulationBuilder from pyhelios.util import flight_planner import helper_funcs import numpy as np from osgeo import gdal import rasterio as rio import laspy <p>To execute LAStools commands, we need to provide the LAStools directory. This may be a different location on your computer, so you will have to provide the correct path:</p> In\u00a0[2]: Copied! <pre># configure LAStools root\nlastools_root = \"C:/LAStools\"\n</pre> # configure LAStools root lastools_root = \"C:/LAStools\" <p>You can find a comprehensive documentation in the HELIOS Wiki.</p> In\u00a0[3]: Copied! <pre>Path(\"data/output\").mkdir(parents=True, exist_ok=True)\nbbox = [20103.0, 312815.0, 20596.0, 312410.0]\nterrain = \"data/StA_last_dtm.tiff\"\nterrain_sub = \"data/output/StA_last_filtered_sub.tiff\"\n!gdal_translate -projwin 20103.0 312815.0 20596.0 312410.0 $terrain $terrain_sub\n</pre> Path(\"data/output\").mkdir(parents=True, exist_ok=True) bbox = [20103.0, 312815.0, 20596.0, 312410.0] terrain = \"data/StA_last_dtm.tiff\" terrain_sub = \"data/output/StA_last_filtered_sub.tiff\" !gdal_translate -projwin 20103.0 312815.0 20596.0 312410.0 $terrain $terrain_sub <pre>Input file size is 801, 751\n0...10...20...30...40...50...60...70...80...90...100 - done.\n</pre> <p>Using LAStools \"las2txt\", we convert the LAZ file of the study site to an ASCII file and extract only vegetation points, which have classification values of 0.</p> In\u00a0[4]: Copied! <pre>vegetation = \"data/output/StA_last_vegetation.xyz\"\n!$lastools_root/bin/las2txt64.exe -i data/StA_last.laz -o $vegetation -keep_classification 0 -parse xyz\n</pre> vegetation = \"data/output/StA_last_vegetation.xyz\" !$lastools_root/bin/las2txt64.exe -i data/StA_last.laz -o $vegetation -keep_classification 0 -parse xyz <p>Using the same bounding box as above, we also extract a spatial subset of the vegetation points.</p> In\u00a0[5]: Copied! <pre>vegetation_sub = \"data/output/StA_last_vegetation_sub.xyz\"\n\nvegetation_arr = np.loadtxt(vegetation)\nidx_sub = (vegetation_arr[:, 0] &gt; bbox[0]) &amp; (vegetation_arr[:, 0] &lt; bbox[2]) &amp; (vegetation_arr[:, 1] &gt; bbox[3]) &amp; (vegetation_arr[:, 1] &lt; bbox[1])\nvegetation_arr_sub = vegetation_arr[idx_sub, :]\nnp.savetxt(vegetation_sub, vegetation_arr_sub, fmt=\"%.6f\")\n\nvoxel_size = 0.25\n</pre> vegetation_sub = \"data/output/StA_last_vegetation_sub.xyz\"  vegetation_arr = np.loadtxt(vegetation) idx_sub = (vegetation_arr[:, 0] &gt; bbox[0]) &amp; (vegetation_arr[:, 0] &lt; bbox[2]) &amp; (vegetation_arr[:, 1] &gt; bbox[3]) &amp; (vegetation_arr[:, 1] &lt; bbox[1]) vegetation_arr_sub = vegetation_arr[idx_sub, :] np.savetxt(vegetation_sub, vegetation_arr_sub, fmt=\"%.6f\")  voxel_size = 0.25 <p>Writing the scene</p> <p>We now have the two files from which we will load the scene parts (stored in the Python variables <code>terrain_sub</code> and <code>vegetation_sub</code>). We have furthermore defined a <code>voxel_size</code> for voxelizing the vegetation points.</p> <p>With this information, we can write the scene. HELIOS++ uses XML files for configuring scanners, platforms, surveys and scenes. Below, we write the scene XML file and fill in the values we defined before (<code>terrain_sub</code>, <code>vegetation_sub</code>, <code>voxel_size</code>). Note how each scene part is embedded in a <code>&lt;part&gt;</code> tag and uses a different \"loader\" <code>filter</code> depending on the file format.</p> In\u00a0[6]: Copied! <pre># Writing the scene XML file\nscene_content = f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;document&gt;\n    &lt;scene id=\"helios_scene\" name=\"HELIOS scene\"&gt;\n        \n        &lt;part&gt;\n            &lt;filter type=\"geotiffloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"{terrain_sub}\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"xyzloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"{vegetation_sub}\" /&gt;\n                &lt;param type=\"string\" key=\"separator\" value=\" \" /&gt;\n                &lt;param type=\"double\" key=\"voxelSize\" value=\"{voxel_size}\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n    &lt;/scene&gt;\n&lt;/document&gt;\n\"\"\"\n</pre> # Writing the scene XML file scene_content = f\"\"\"  \"\"\" In\u00a0[7]: Copied! <pre># save scene file to the current directory\nscene_file = \"StA_helios_scene_small.xml\"\nwith open(scene_file, \"w\") as f:\n    f.write(scene_content)\n</pre> # save scene file to the current directory scene_file = \"StA_helios_scene_small.xml\" with open(scene_file, \"w\") as f:     f.write(scene_content) In\u00a0[8]: Copied! <pre>platform = \"copter_linearpath\"\nscanner = \"riegl_vux-1uav22\"\n</pre> platform = \"copter_linearpath\" scanner = \"riegl_vux-1uav22\" In\u00a0[9]: Copied! <pre>height_agl = 120\nbbox = [20250, 312450, 20550, 312700]\nwaypoints, centre, distance = flight_planner.compute_flight_lines(bounding_box=bbox,\n                                               spacing=75,\n                                               rotate_deg=-10,\n                                               flight_pattern=\"parallel\")\n# add an additional point between the long flight lines\nnew_waypoints = helper_funcs.add_support_points(waypoints)\n# add z-values to waypoints using a height above the terrain\nwaypoints_with_z = helper_funcs.waypoints_above_ground(new_waypoints, terrain_sub, height_agl)\n</pre> height_agl = 120 bbox = [20250, 312450, 20550, 312700] waypoints, centre, distance = flight_planner.compute_flight_lines(bounding_box=bbox,                                                spacing=75,                                                rotate_deg=-10,                                                flight_pattern=\"parallel\") # add an additional point between the long flight lines new_waypoints = helper_funcs.add_support_points(waypoints) # add z-values to waypoints using a height above the terrain waypoints_with_z = helper_funcs.waypoints_above_ground(new_waypoints, terrain_sub, height_agl) <p>Let's plot the resulting trajecotry on top of the terrain to see if it covers the study site well.</p> In\u00a0[10]: Copied! <pre>dtm, tf, bounds, origin_left, origin_bottom, origin_right, origin_top = helper_funcs.read_raster(terrain_sub)\nplt.imshow(dtm, cmap=\"terrain\", extent=[origin_left, origin_right, origin_bottom, origin_top])\nplt.plot(waypoints_with_z[:, 0], waypoints_with_z[:, 1])\nplt.show()\n</pre> dtm, tf, bounds, origin_left, origin_bottom, origin_right, origin_top = helper_funcs.read_raster(terrain_sub) plt.imshow(dtm, cmap=\"terrain\", extent=[origin_left, origin_right, origin_bottom, origin_top]) plt.plot(waypoints_with_z[:, 0], waypoints_with_z[:, 1]) plt.show() <p>Acquisition settings</p> <p>Now we configure the acquisition settings.</p> In\u00a0[11]: Copied! <pre>flight_v = 8  # velocity in m/s\npulse_freq = 200_000  # pulse frequency in Hz\nscan_freq = 50  # scan frequency in Hz\nscan_angle = 90  # scan angle in degrees\n</pre> flight_v = 8  # velocity in m/s pulse_freq = 200_000  # pulse frequency in Hz scan_freq = 50  # scan frequency in Hz scan_angle = 90  # scan angle in degrees <p>Writing the survey file</p> <p>Now we can write the survey file, which is also an XML file. You can find further examples in the HELIOS++ demo data folder.</p> In\u00a0[12]: Copied! <pre>legs = \"\"\nfor i in range(waypoints_with_z.shape[0]):\n    x, y, z = waypoints_with_z[i]\n    \n    legs += f'''\n    &lt;leg&gt;\n            &lt;platformSettings x=\"{x}\" y=\"{y}\" z=\"{z}\" template=\"platform_uls\"/&gt;\n            &lt;scannerSettings template=\"scanner_uls\" active=\"true\"/&gt;\n    &lt;/leg&gt;'''\n</pre> legs = \"\" for i in range(waypoints_with_z.shape[0]):     x, y, z = waypoints_with_z[i]          legs += f'''      ''' <p>Note how the survey below links to the <code>scanner</code> and <code>scene</code> that we defined earlier.</p> In\u00a0[13]: Copied! <pre>survey_content = f'''&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;document&gt;\n    &lt;platformSettings id=\"platform_uls\" movePerSec_m=\"{flight_v}\"/&gt;\n    &lt;scannerSettings active=\"true\" id=\"scanner_uls\" trajectoryTimeInterval_s=\"0.01\" pulseFreq_hz=\"{pulse_freq}\" scanAngle_deg=\"{scan_angle}\" scanFreq_hz=\"{scan_freq}\"/&gt;\n    &lt;survey name=\"uls_survey\" platform=\"data/platforms.xml#{platform}\" scanner=\"data/scanners_als.xml#{scanner}\" scene=\"{scene_file}#helios_scene\"&gt;\n    &lt;FWFSettings beamSampleQuality=\"3\" winSize_ns=\"1.5\"/&gt;\n    {legs}\n    &lt;/survey&gt;\n&lt;/document&gt;\n''' \n</pre> survey_content = f'''      {legs}       '''  In\u00a0[14]: Copied! <pre>survey_file = \"uls_StA_survey.xml\"\nwith open(survey_file, 'w') as f:\n    f.write(survey_content)\n</pre> survey_file = \"uls_StA_survey.xml\" with open(survey_file, 'w') as f:     f.write(survey_content) In\u00a0[15]: Copied! <pre>pyhelios.loggingDefault()\nsimB = SimulationBuilder(str(survey_file), ['assets/'], 'helios_output/')\nsimB.setLasOutput(True)\nsimB.setZipOutput(True)\n\n# build the simulation\nsim = simB.build()\n\n# Start the simulation.\nstart_time = time.time()\nsim.start()\n\nif sim.isStarted():\n    print(f'Simulation has started!\\nSurvey Name: {sim.sim.getSurvey().name}\\n{sim.sim.getScanner().toString()}')\n\nwhile sim.isRunning():\n    duration = time.time()-start_time\n    mins = duration // 60\n    secs = duration % 60\n    print('\\r'+f'Simulation has been running for {int(mins)} min and {int(secs)} sec. Please wait.', end='')\n    time.sleep(1)\n\nif sim.isFinished():\n    print('\\n'+'Simulation has finished!')\n\noutput = sim.join()\nmeas, traj = pyhelios.outputToNumpy(output)\n</pre> pyhelios.loggingDefault() simB = SimulationBuilder(str(survey_file), ['assets/'], 'helios_output/') simB.setLasOutput(True) simB.setZipOutput(True)  # build the simulation sim = simB.build()  # Start the simulation. start_time = time.time() sim.start()  if sim.isStarted():     print(f'Simulation has started!\\nSurvey Name: {sim.sim.getSurvey().name}\\n{sim.sim.getScanner().toString()}')  while sim.isRunning():     duration = time.time()-start_time     mins = duration // 60     secs = duration % 60     print('\\r'+f'Simulation has been running for {int(mins)} min and {int(secs)} sec. Please wait.', end='')     time.sleep(1)  if sim.isFinished():     print('\\n'+'Simulation has finished!')  output = sim.join() meas, traj = pyhelios.outputToNumpy(output) <pre>SimulationBuilder is building simulation ...\nSimulationBuilder built simulation in 35.50971379999828 seconds\nSimulation has started!\nSurvey Name: uls_survey\nScanner: riegl_vux-1uav22\nDevice[0]: riegl_vux-1uav22\n\tAverage Power: 4 W\n\tBeam Divergence: 0.5 mrad\n\tWavelength: 1064 nm\n\tVisibility: 23 km\n\nSimulation has been running for 1 min and 16 sec. Please wait.\nSimulation has finished!\n</pre> In\u00a0[16]: Copied! <pre># Load the real-world data\nlas = laspy.read(\"data/StA_last.laz\")\nref = np.array([las.x, las.y, las.z]).T\n</pre> # Load the real-world data las = laspy.read(\"data/StA_last.laz\") ref = np.array([las.x, las.y, las.z]).T In\u00a0[17]: Copied! <pre>%matplotlib inline\n# plotting a cross section\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(20, 8))\n\nfor pc, ax, title in zip([meas, ref], [ax1, ax2], [\"Simulated (UAV-LS)\", \"Real-world (ALS)\"]):\n    idx = (pc[:, 1] &gt; 312580) &amp; (pc[:, 1] &lt; 312590) &amp; (pc[:, 0] &gt; 20100) &amp; (pc[:, 0] &lt; 20600)\n    ax.scatter(pc[idx, 0], pc[idx, 2], c=pc[idx, 2], s=0.02, cmap=\"terrain\")\n    ax.set_xlabel(\"X [m]\")\n    ax.set_ylabel(\"Z [m]\")\n    ax.set_title(title)\n    ax.axis('equal')\n\nplt.tight_layout()\nplt.show()\n</pre> %matplotlib inline # plotting a cross section fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(20, 8))  for pc, ax, title in zip([meas, ref], [ax1, ax2], [\"Simulated (UAV-LS)\", \"Real-world (ALS)\"]):     idx = (pc[:, 1] &gt; 312580) &amp; (pc[:, 1] &lt; 312590) &amp; (pc[:, 0] &gt; 20100) &amp; (pc[:, 0] &lt; 20600)     ax.scatter(pc[idx, 0], pc[idx, 2], c=pc[idx, 2], s=0.02, cmap=\"terrain\")     ax.set_xlabel(\"X [m]\")     ax.set_ylabel(\"Z [m]\")     ax.set_title(title)     ax.axis('equal')  plt.tight_layout() plt.show() <p>The great thing about the simulation is that we have perfect reference data. Since we provided the ground and the vegetation separately, they receive different \"object IDs\". We can use this ID (stored in column 14 of our measurement array) to extract just the point clouds and visualize them.</p> <p>These ground points could then also be used as reference testing different afwizard workflows for different datasets.</p> In\u00a0[18]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(20, 10))\nmeas_ground = meas[meas[:, 14] == 0, :]  # extracting only ground points from simulated data\nref_ground = ref[las[\"classification\"] == 2, :]  # extracting only ground points from real data\n\nfor pc, ax, title in zip([meas_ground, ref_ground], [ax1, ax2], [\"Simulated\", \"Real-world\"]):\n    # We will only plot every 2nd point so it's faster\n    ax.scatter(pc[::2, 0], pc[::2, 1], c=pc[::2, 2], s=0.02, cmap=\"terrain\")\n    ax.set_xlabel(\"X [m]\")\n    ax.set_ylabel(\"Y [m]\")\n    ax.set_xlim(bbox[0], bbox[2])\n    ax.set_ylim(bbox[1], bbox[3])\n    ax.set_aspect(\"equal\")\n    ax.set_title(title)\n\nplt.tight_layout()\nplt.show()\n</pre> fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(20, 10)) meas_ground = meas[meas[:, 14] == 0, :]  # extracting only ground points from simulated data ref_ground = ref[las[\"classification\"] == 2, :]  # extracting only ground points from real data  for pc, ax, title in zip([meas_ground, ref_ground], [ax1, ax2], [\"Simulated\", \"Real-world\"]):     # We will only plot every 2nd point so it's faster     ax.scatter(pc[::2, 0], pc[::2, 1], c=pc[::2, 2], s=0.02, cmap=\"terrain\")     ax.set_xlabel(\"X [m]\")     ax.set_ylabel(\"Y [m]\")     ax.set_xlim(bbox[0], bbox[2])     ax.set_ylim(bbox[1], bbox[3])     ax.set_aspect(\"equal\")     ax.set_title(title)  plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"helios_uls.html#an-introduction-to-lidar-simulation-with-helios","title":"An Introduction to LiDAR Simulation with HELIOS++\u00b6","text":"<p>II: UAV-borne laser scanning</p>"},{"location":"helios_uls.html#1-the-virtual-scene","title":"1. The virtual scene\u00b6","text":"<p>The first component of a simulation is the 3D input scene. HELIOS++ supports loading different file format, including Wavefront OBJ triangle meshes, GeoTIFF rasters or XYZ point clouds, which will be converted to voxel models. In this tutorial, we will use GeoTIFF for loading terrain and XYZ files for loading voxelized vegetation.</p> <p>Preparing the scene parts</p> <p>We will first get a spatial subset of the terrain model using <code>gdal_translate</code>.</p> <p>Note: With the exclamation mark (<code>!</code>), we can issue a shell command and hence run the command line tools of GDAL and LAStools.</p>"},{"location":"helios_uls.html#2-selection-of-platform-and-scanner","title":"2. Selection of platform and scanner\u00b6","text":"<p>In the first scenario, we will select a UAV platform (copter). As scanner, we choose the \"RIEGL VUX-1UAV-22\".</p> <p>Feel free to try out other scanners in python/pyhelios/data/scanners_als.xml but please notice that different scanner types require different survey specifications.</p>"},{"location":"helios_uls.html#3-specification-of-the-survey","title":"3. Specification of the survey\u00b6","text":"<p>Waypoints (trajectory)</p> <p>We will use the <code>flight_planner</code> utility tool of HELIOS++ to easily generate a trajecotry. We also modify the waypoints with some helper functions to follow a height above the terrain.</p>"},{"location":"helios_uls.html#4-running-the-simulation","title":"4. Running the simulation\u00b6","text":""},{"location":"helios_uls.html#5-visualization","title":"5. Visualization\u00b6","text":"<p>Using side views and top views, we visualise the simulated and real-world data to compare them.</p>"},{"location":"helper_funcs.html","title":"Helper funcs","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nfrom pathlib import Path\nimport time\nimport matplotlib.pyplot as plt\nimport matplotlib\nfrom ipywidgets import interact\nimport pyhelios\nfrom pyhelios import SimulationBuilder\nimport numpy as np\nfrom osgeo import gdal\nimport rasterio as rio\nimport laspy\n</pre> import os from pathlib import Path import time import matplotlib.pyplot as plt import matplotlib from ipywidgets import interact import pyhelios from pyhelios import SimulationBuilder import numpy as np from osgeo import gdal import rasterio as rio import laspy In\u00a0[\u00a0]: Copied! <pre>def tellme(s):\n    plt.title(s, fontsize=12)\n    plt.draw()\n</pre> def tellme(s):     plt.title(s, fontsize=12)     plt.draw() In\u00a0[\u00a0]: Copied! <pre>def read_raster(raster_file):\n    with rio.open(raster_file) as src:\n        dem = src.read(1, masked=True)\n        tf = src.transform\n        bounds = src.bounds\n        width= src.width\n        height = src.height\n    origin_left, origin_bottom, origin_right, origin_top = bounds\n    \n    return dem, tf, bounds, origin_left, origin_bottom, origin_right, origin_top\n</pre> def read_raster(raster_file):     with rio.open(raster_file) as src:         dem = src.read(1, masked=True)         tf = src.transform         bounds = src.bounds         width= src.width         height = src.height     origin_left, origin_bottom, origin_right, origin_top = bounds          return dem, tf, bounds, origin_left, origin_bottom, origin_right, origin_top In\u00a0[\u00a0]: Copied! <pre>def interactive_flight_trajectory(dtm, tf, n_pos=4):\n    plt.figure(figsize=(10, 8))\n\n    zoom_out = 100\n    \n    plt.imshow(dtm, cmap='terrain')\n    plt.colorbar(label=\"terrain height [m]\")\n\n    plt.axis('equal')\n\n    ax = plt.gca()\n    ax.set_xlim([-zoom_out, np.shape(dtm)[1]+zoom_out])\n    ax.set_ylim([np.shape(dtm)[0]+zoom_out, -zoom_out])\n\n    tellme('Select the trajectory of the aircraft carrying the virtual laser scanner.')\n\n    plt.waitforbuttonpress()\n\n    while True:\n        pt = []\n        while len(pt) &lt; n_pos:\n            tellme(f'Please choose {n_pos} positions with the mouse.')\n            pt = np.asarray(plt.ginput(n_pos, timeout=-1))\n        for k in range(n_pos):\n            if k % 2 != 0 or k == n_pos:\n                continue\n            line = plt.plot([pt[k][0], pt[k+1][0]], [pt[k][1], pt[k+1][1]], label=f'Pass {int(k/2)+1}', color='steelblue')  # 'firebrick'\n            ar_length = 10000\n            arrow = plt.arrow(pt[k+1][0], pt[k+1][1], -(pt[k][0]-pt[k+1][0])/ar_length, (pt[k+1][1]-pt[k][1])/ar_length, head_width=50, edgecolor='none', facecolor='steelblue')\n        plt.legend()\n\n        tellme('Happy?\\nKeypress for \"Yes\", mouseclick for \"No\"')\n\n        if plt.waitforbuttonpress(timeout=-1):\n            plt.close()\n            break\n\n        ax = plt.gca()\n\n        for art in ax.get_children():\n            if isinstance(art, matplotlib.patches.FancyArrow) or isinstance(art, matplotlib.lines.Line2D):\n                art.remove()\n    \n    waypoints = []\n    for i in range(len(pt)):\n        x, y = tf * (pt[i][0], pt[i][1])\n        waypoints.append([x, y])\n                 \n    print(f\"You have chosen your flight lines.\\n{[[float(np.round(x, 2)), float(np.round(y, 2))] for x, y in waypoints]}\")\n    \n    return waypoints\n</pre> def interactive_flight_trajectory(dtm, tf, n_pos=4):     plt.figure(figsize=(10, 8))      zoom_out = 100          plt.imshow(dtm, cmap='terrain')     plt.colorbar(label=\"terrain height [m]\")      plt.axis('equal')      ax = plt.gca()     ax.set_xlim([-zoom_out, np.shape(dtm)[1]+zoom_out])     ax.set_ylim([np.shape(dtm)[0]+zoom_out, -zoom_out])      tellme('Select the trajectory of the aircraft carrying the virtual laser scanner.')      plt.waitforbuttonpress()      while True:         pt = []         while len(pt) &lt; n_pos:             tellme(f'Please choose {n_pos} positions with the mouse.')             pt = np.asarray(plt.ginput(n_pos, timeout=-1))         for k in range(n_pos):             if k % 2 != 0 or k == n_pos:                 continue             line = plt.plot([pt[k][0], pt[k+1][0]], [pt[k][1], pt[k+1][1]], label=f'Pass {int(k/2)+1}', color='steelblue')  # 'firebrick'             ar_length = 10000             arrow = plt.arrow(pt[k+1][0], pt[k+1][1], -(pt[k][0]-pt[k+1][0])/ar_length, (pt[k+1][1]-pt[k][1])/ar_length, head_width=50, edgecolor='none', facecolor='steelblue')         plt.legend()          tellme('Happy?\\nKeypress for \"Yes\", mouseclick for \"No\"')          if plt.waitforbuttonpress(timeout=-1):             plt.close()             break          ax = plt.gca()          for art in ax.get_children():             if isinstance(art, matplotlib.patches.FancyArrow) or isinstance(art, matplotlib.lines.Line2D):                 art.remove()          waypoints = []     for i in range(len(pt)):         x, y = tf * (pt[i][0], pt[i][1])         waypoints.append([x, y])                       print(f\"You have chosen your flight lines.\\n{[[float(np.round(x, 2)), float(np.round(y, 2))] for x, y in waypoints]}\")          return waypoints In\u00a0[\u00a0]: Copied! <pre>def find_playback_dir(survey_path, output_folder='output', helios_root=None):\n    if not helios_root:\n        helios_root = os.getcwd()\n    playback = Path(helios_root) / output_folder\n    with open(Path(helios_root) / survey_path, 'r') as sf:\n        for line in sf:\n            if '&lt;survey name' in line:\n                survey_name = line.split('name=\"')[1].split('\"')[0]\n    if not (playback / survey_name).is_dir():\n        raise FileNotFoundError('Could not locate output directory')\n    last_run_dir = sorted(list((playback / survey_name).glob('*')), key=lambda f: f.stat().st_ctime, reverse=True)[0]\n    return last_run_dir\n</pre> def find_playback_dir(survey_path, output_folder='output', helios_root=None):     if not helios_root:         helios_root = os.getcwd()     playback = Path(helios_root) / output_folder     with open(Path(helios_root) / survey_path, 'r') as sf:         for line in sf:             if ' In\u00a0[\u00a0]: Copied! <pre>def read_strip(path):\n    las = laspy.read(path)\n    pc = np.array([las.x, las.y, las.z]).T\n    object_id = las[\"hitObjectId\"]\n    gps_time = las[\"gps_time\"]\n    classification = las[\"classification\"]\n\n    return pc, object_id, gps_time, classification\n</pre> def read_strip(path):     las = laspy.read(path)     pc = np.array([las.x, las.y, las.z]).T     object_id = las[\"hitObjectId\"]     gps_time = las[\"gps_time\"]     classification = las[\"classification\"]      return pc, object_id, gps_time, classification In\u00a0[\u00a0]: Copied! <pre>def add_support_points(waypoints):\n    indices = np.arange(0, waypoints.shape[0], 2)\n    new_waypoints = []\n    for idx in indices:\n        wp = waypoints[idx, :]\n        new_waypoints.append(wp)\n        wp2 = waypoints[idx+1, :]\n        new_wp = wp + (wp2[:2] - wp[:2]) / 2\n        new_waypoints.append(new_wp)\n        new_waypoints.append(wp2)\n\n    return new_waypoints\n</pre> def add_support_points(waypoints):     indices = np.arange(0, waypoints.shape[0], 2)     new_waypoints = []     for idx in indices:         wp = waypoints[idx, :]         new_waypoints.append(wp)         wp2 = waypoints[idx+1, :]         new_wp = wp + (wp2[:2] - wp[:2]) / 2         new_waypoints.append(new_wp)         new_waypoints.append(wp2)      return new_waypoints In\u00a0[\u00a0]: Copied! <pre>def waypoints_above_ground(waypoints, dtm_file, height_agl):\n    src = rio.open(dtm_file)\n    mean_dtm_height = np.mean(src.read(1, masked=True))\n    vals = np.array([z for z in src.sample(waypoints)])[:, 0]\n    vals[vals &lt; 0] = mean_dtm_height\n    vals += height_agl\n    \n    return np.column_stack((waypoints, vals))\n</pre> def waypoints_above_ground(waypoints, dtm_file, height_agl):     src = rio.open(dtm_file)     mean_dtm_height = np.mean(src.read(1, masked=True))     vals = np.array([z for z in src.sample(waypoints)])[:, 0]     vals[vals &lt; 0] = mean_dtm_height     vals += height_agl          return np.column_stack((waypoints, vals))"},{"location":"imports.html","title":"Imports","text":"<p>This notebook tests if the installation was successful by importing the required libraries.</p> In\u00a0[1]: Copied! <pre># imports\nimport pyhelios\nimport afwizard\nimport numpy\nimport matplotlib\nfrom osgeo import gdal\nimport rasterio as rio\nimport laspy\n</pre> # imports import pyhelios import afwizard import numpy import matplotlib from osgeo import gdal import rasterio as rio import laspy In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"imports.html#imports","title":"Imports\u00b6","text":""},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#installation-and-download","title":"Installation and Download","text":"<p>In this workshop, we will use </p> <ul> <li>the AFwizard library for advanced ground point filtering in LiDAR data, and</li> <li>HELIOS++ for LiDAR simulation.</li> </ul> <p>First, we will download the data and code. We then install Miniforge, a distribution of the <code>conda</code> and <code>mamba</code> package managers. This will allow us to install and manage Python and the required libraries in a dedicated environment. In addition, we will install LAStools, a popular toolbox for LiDAR data processing, which is required by a module in AFwizard.</p> <p>If you have any questions or problems with installation, please contact Hannah Weiser.</p>"},{"location":"installation.html#1-dataset-and-code","title":"1. Dataset and Code","text":"<p>Download (heiBOX)</p> <p>Instructions:</p> <ul> <li>Click on the \"Download data (heiBOX)\" link above and download as \"ZIP\" (green button).</li> <li>Unzip the archive to a folder named <code>trail-groundfiltering</code> (i.e., keep the default name). Note down the path to this folder, as you will need it later (see Section 4.4).</li> <li>Now you are all set up and have both the scripts (<code>.ipynb</code> and <code>.py</code> files) and data (in the <code>data</code> subfolder).</li> </ul>"},{"location":"installation.html#2-mamba","title":"2. Mamba","text":"<p>Mamba is a fast, robust, and cross-platform package manager. As recommended by the developers, we will install Mamba through the Miniforge distribution. Follow the instructions from this page: Mamba Installation. We provide a short summary below.</p> <p>Here is the direct link to the Windows installer: https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Windows-x86_64.exe. Follow the prompts, taking note of the option to \"Create start menu shortcuts\".</p> <p>For installation on Unix-like platforms, follow the instructions at: https://github.com/conda-forge/miniforge?tab=readme-ov-file#unix-like-platforms-macos-linux--wsl. </p>"},{"location":"installation.html#3-lastools","title":"3. LAStools","text":"<p>LAStools is a widely used and efficient toolbox for processing LiDAR data in LAS/LAZ format. It includes tools for filtering, classification, tiling, conversion, and much more. All registered workshop participants will receive a free LAStools license valid for 4 weeks during the in-person workshop.</p> <ul> <li>Download LAStools v2.0.0 from the following URL: https://github.com/LAStools/LAStools/releases/download/v2.0.0/LAStools.zip. IMPORTANT: Use this specific version to ensure compatibility with AFwizard. The newest LAStools version will not work in the demo or trial license version.</li> <li>After downloading, extract the contents of the ZIP/TAR archive to a directory of your choice, e.g., <code>C:\\LAStools</code>. Remember this path, as you will later need to set it in the AFwizard notebooks.</li> </ul> <p>If you are on Linux or Mac OS, install LAStools using \"Wine\" as described here: https://rapidlasso.de/using-lastools-on-mac-os-x-with-wine/. In step 2 of this tutorial, download LAStools v2.0.0 as indicated above instead of the version linked in the tutorial.</p>"},{"location":"installation.html#4-mamba-environment-with-needed-libraries","title":"4. Mamba environment with needed libraries","text":"<p>To create a Mamba environment with the necessary libraries, follow these steps:</p> <ol> <li>Open a terminal (Miniforge Prompt on Windows, Terminal on macOS/Linux).</li> <li> <p>Create a new <code>mamba</code> environment named <code>groundfiltering</code> with Python 3.13, AFwizard and HELIOS++:</p> <p></p><pre><code>mamba create -n groundfiltering python afwizard helios=2.0.2 rasterio laspy scipy -c conda-forge\n</code></pre> This might take a few minutes (for lower end devices up to 20 minutes) as <code>mamba</code> resolves dependencies and downloads the required packages. Just be patient and wait. 3. Close Miniforge. Reopen the Miniforge prompt and activate the newly created environment by typing: <pre><code>mamba activate groundfiltering\n</code></pre> </li> <li> <p>Change to your <code>trail-groundfiltering</code> directory (see Section 1) and start Jupyter Lab:</p> <pre><code>cd path/to/trail-groundfiltering\njupyter-lab\n</code></pre> </li> <li> <p>Open the imports notebook and execute the code cell to verify the installation. In the workshop, use steps 1, 3 and 4 to start Jupyter Lab and open the notebooks.</p> </li> </ol>"},{"location":"installation.html#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Issue when trying to activate the environment:</li> </ul> <pre><code>critical libmamba Shell not initialized\n\n'mamba' is running as a subprocess and can't modify the parent shell.\n Thus you must initialize your shell before using activate and deactivate.\n</code></pre> <ul> <li>Solution: Close and reopen the Miniforge prompt and try again.</li> </ul>"},{"location":"installation.html#further-information-advanced","title":"Further information (advanced)","text":""},{"location":"installation.html#git-repository","title":"Git repository","text":"<p>This website is hosted on GitHub: https://github.com/3dgeo-heidelberg/trail-groundfiltering</p> <p>If you have <code>git</code> installed, you can also clone the repository using: </p><pre><code>git clone https://github.com/3dgeo-heidelberg/trail-groundfiltering.git\n</code></pre> <p>You find the scripts in the <code>docs</code> folder and would need to place the data in the <code>data</code> subfolder.</p>"},{"location":"installation.html#useful-terminal-commands","title":"Useful terminal commands","text":"<ul> <li> <p>To navigate between folders use <code>cd</code> (change directory): <code>cd \"C:\\my folder\\my sub-folder\"</code> ATTENTION: if your folders or files contain spaces, you should use quotation marks \" \".</p> </li> <li> <p>To list existing environments : <code>mamba env list</code></p> </li> <li> <p>To activate an environment :  <code>mamba activate __my_environment__</code> (in our case: <code>mamba activate groundfiltering</code>)</p> </li> <li> <p>To open Jupyter notebooks : <code>jupyter-lab __my_notebook__.ipynb</code></p> </li> <li> <p>To list dependencies once you are in an active environement: <code>mamba list</code></p> </li> <li> <p>... something is missing - we can add it on the go (provided that we're inside an active environment) : <code>mamba install __my_package__</code></p> </li> </ul>"},{"location":"installation.html#additional-resources","title":"Additional resources","text":"<p>For more information using <code>mamba</code> and <code>conda</code>, you can refer to the following resources:</p> <ul> <li>Mamba user guide</li> <li>Conda documentation</li> </ul> <p>If you want to use LAStools standalone, you can find the documentation here:</p> <ul> <li>LAStools documentation</li> </ul>"},{"location":"workflow_PK.html","title":"Study site 1","text":"In\u00a0[\u00a0]: Copied! <pre>import afwizard as af\n</pre> import afwizard as af <p>Now, we have to set the LAStools directory to the path where we installed LAStools. This may be a different location on your computer, so you will have to provide the correct path:</p> In\u00a0[\u00a0]: Copied! <pre>af.set_lastools_directory(\"C:/LAStools\")\n</pre> af.set_lastools_directory(\"C:/LAStools\") <p>The next steps are to create the directory \"filters\", where we will later save our developed filter pipelines. After that, we set the directory where the input data is located and where the output data will be written. In case, the directory is not existing, it will be created.</p> In\u00a0[\u00a0]: Copied! <pre>af.set_data_directory(\"filters\", create_dir=True)\n</pre> af.set_data_directory(\"filters\", create_dir=True) In\u00a0[\u00a0]: Copied! <pre>af.set_data_directory(\"data\", create_dir=True)\n</pre> af.set_data_directory(\"data\", create_dir=True) <p>Now we can load our first dataset by file name and additionally provide the spatial reference system. Make sure that the data are copied to your data directory specified just before.</p> In\u00a0[\u00a0]: Copied! <pre>ds = af.DataSet(filename=\"PK_last.laz\", spatial_reference=\"EPSG:25833\")\n</pre> ds = af.DataSet(filename=\"PK_last.laz\", spatial_reference=\"EPSG:25833\") <p>We remove any existing classification from the dataset.</p> In\u00a0[\u00a0]: Copied! <pre>ds = af.remove_classification(ds)\n</pre> ds = af.remove_classification(ds) <p>Since the dataset covers both land and water, the goal is to split our dataset in two segments to process these areas separately. To help us, we load a GeoJSON file containing a pre-prepared segmentation of the LiDAR tile. In case you want to produce your own segmentation, you can use e.g. QGIS: create a shapefile, draw the segments (the shapes must not overlap and there must not be areas in your dataset not covered by a segment) and export the Shapefile as GeoJSON.</p> In\u00a0[\u00a0]: Copied! <pre>segmentation = af.load_segmentation(\n    \"PK_segments.geojson\", spatial_reference=\"EPSG:25833\"\n)\n</pre> segmentation = af.load_segmentation(     \"PK_segments.geojson\", spatial_reference=\"EPSG:25833\" ) <p>Since the segments in the segmentation may cover large areas and contain many points, we sample our segments using the <code>restrict</code> method of <code>afwizard</code>. This will make the process of creating filter pipelines much faster! The aim is to select characteristic subareas, one for each segment running following command. The command will open a GUI showing the segments on a map. If you want to see a draft hillshade version of the DTM, click on \"Visualize\".</p> <p>Click the small polygon on the sidebar on the left to draw a segmentation polygon for the land area. When you are done, finish by clicking \"Finalize\". Your restricted dataset is then saved to the variable <code>rds</code>. Save the data by executing the next code cell (<code>saved = rds.save(...)</code>). Then repeat the <code>restrict</code> and the <code>save</code> step for the water area as well. For the water area, the filename is changed to <code>\"data/sample_uw.las\"</code> when saving (see below).</p> In\u00a0[\u00a0]: Copied! <pre>rds = ds.restrict(segmentation_overlay=segmentation)\n</pre> rds = ds.restrict(segmentation_overlay=segmentation) In\u00a0[\u00a0]: Copied! <pre>saved = rds.save(\"data/sample_stonewall.las\", overwrite=True)\n</pre> saved = rds.save(\"data/sample_stonewall.las\", overwrite=True) <p>The same procedure is now repeated for the submerged terrain:</p> In\u00a0[\u00a0]: Copied! <pre>rds = ds.restrict(segmentation_overlay=segmentation)\n</pre> rds = ds.restrict(segmentation_overlay=segmentation) In\u00a0[\u00a0]: Copied! <pre>saved = rds.save(\"data/sample_uw.las\", overwrite=True)\n</pre> saved = rds.save(\"data/sample_uw.las\", overwrite=True) <p>Now we can create targeted filter pipelines for the two datasets we created before. This is done using the interactive <code>pipeline_tuning</code> function. Here, you can select from different outlier filtering and ground filtering algorithms and combine them in a sequential filter pipeline. You can preview the result of different versions of your pipelines and delete filtering steps if it turns out they are not needed or need different settings. We do this step twice, for each of our two segments.</p> In\u00a0[\u00a0]: Copied! <pre>sampledataset1 = af.DataSet(filename=\"data/sample_stonewall.las\", spatial_reference=\"EPSG:25833\")\n</pre> sampledataset1 = af.DataSet(filename=\"data/sample_stonewall.las\", spatial_reference=\"EPSG:25833\") <p>The following command will open the GUI for creating a filter pipeline. In the centre, the point cloud of the spatial sample is visualized as hillshade, slope or a combination of both. Visualization settings can be tuned using the fields in the right column.</p> <p>In the center, a tab (#0) with an image is displayed showing the unclassified data as hillshade.</p> <p>In the left column, a filter can be added to the pipeline. Click on \"Pipeline stages\" and then on \"+ Add entry\" and select the filter algorithm of your choice (here: lasground_new (LASTools)). Finally, you can set the parameters (offset, spike, step). Here, we let them at their defaut values. (0, 0.5, 1). Clicking \"Preview\" button on top of the right column will trigger the filtering of the sample using the current filter and parameter strings and display the result as a new window in tab \"#1\" in the centre column (with the preset hillshade at 45\u00b0 altitude and 0.2 m resolution). Before finalizing a finished filtering pipeline, fill in the \"Pipeline metadata\" in the dropdown on the left.</p> In\u00a0[\u00a0]: Copied! <pre>pipeline1 = af.pipeline_tuning(sampledataset1)\n</pre> pipeline1 = af.pipeline_tuning(sampledataset1) In\u00a0[\u00a0]: Copied! <pre>af.save_filter(pipeline1, \"filters/PK_stonewall.json\")\n</pre> af.save_filter(pipeline1, \"filters/PK_stonewall.json\") <p>Now we repeat the procedure for the other segment using our sample from the terrestrial area.</p> In\u00a0[\u00a0]: Copied! <pre>sampledataset2 = af.DataSet(filename=\"sample_uw.las\", spatial_reference=\"EPSG:25833\")\n</pre> sampledataset2 = af.DataSet(filename=\"sample_uw.las\", spatial_reference=\"EPSG:25833\") In\u00a0[\u00a0]: Copied! <pre>pipeline2 = af.pipeline_tuning(sampledataset2)\n</pre> pipeline2 = af.pipeline_tuning(sampledataset2) In\u00a0[\u00a0]: Copied! <pre>af.save_filter(pipeline2, \"filters/PK_uw.json\")\n</pre> af.save_filter(pipeline2, \"filters/PK_uw.json\") <p>Now we map the created filter pipelines to the segmentations.</p> In\u00a0[\u00a0]: Copied! <pre>af.add_filter_library(path=\"filters\", recursive=False)\n</pre> af.add_filter_library(path=\"filters\", recursive=False) <p>Using the selection window below, select the two pipelines you created earlier. Important: You need to select all pipelines that you will need to attach to the segment classes in the following step. Select multiple pipelines by pressing \"Ctrl\" (\"Strg\" on German keyboards). As before, finish the interactive step by clicking \"Finalize\".</p> In\u00a0[\u00a0]: Copied! <pre>pipelines = af.select_pipeline_from_library(\"filters\")\n</pre> pipelines = af.select_pipeline_from_library(\"filters\") <p>In this stage, you select which pipeline to assign to which segment. On the top right, switch in the dropdown menu to \"segment\". You will see that there are now two segments, \"UW\" for \"underwater\" and \"veg\" for \"vegetation\". You can also visualize their outline by clicking on the marker button next to the segment name. In the dropdown menu below each segment, select the corresponding filter you created. When you are done with assigning, click \"Finalize\". Then run the next code cell to save the segments together with their assigned filter pipeline.</p> In\u00a0[\u00a0]: Copied! <pre>assigned_segmentation = af.assign_pipeline(\n    ds, segmentation=segmentation, pipelines=pipelines\n)\n</pre> assigned_segmentation = af.assign_pipeline(     ds, segmentation=segmentation, pipelines=pipelines ) In\u00a0[\u00a0]: Copied! <pre>assigned_segmentation.save(\"data/PK_segments_assigned.geojson\")\n</pre> assigned_segmentation.save(\"data/PK_segments_assigned.geojson\") <p>Finally, the adaptive filtering has to be calculated. This is done on a command line basis. Therefore, open a new Tab using the \"+\" symbol next to the top of this window and cklick on \"Terminal\".</p> <p>ATTENTION: the directories refer relatively to the directory of the prompt in the terminal!</p> <p>In the example below, the prompt is executed from <code>.../trail-groundfiltering</code>. Filesystem is:</p> <ul> <li><code>.../trail-groundfiltering</code></li> <li><code>.../trail-groundfiltering/data</code></li> <li><code>.../trail-groundfiltering/filters</code></li> </ul> <p>Note:</p> <ul> <li>file <code>PK_last.laz</code> is in directory <code>data</code></li> <li>file <code>PK_segments_assigned.geojson</code> is in directory <code>data</code></li> <li>Directory <code>output</code> will be created in <code>data/output</code></li> <li>filters are stored in <code>filters</code></li> </ul> <pre>afwizard --dataset=data/PK_last.laz --dataset-crs=EPSG:25833 --segmentation=data/PK_segments_assigned.geojson --segmentation-crs=EPSG:25833 --output-dir=data/output --library filters --lastools-dir=\"C:\\LAStools\"\n</pre> <p>We can also execute the command line tool by using the <code>!command</code> syntax in the Jupyter notebook. The exclamation mark tells Jupyter that it should pass the command to the shell instead of executing with Python. Let's try it out below.</p> In\u00a0[\u00a0]: Copied! <pre>!afwizard --dataset=data/PK_last.laz --dataset-crs=EPSG:25833 --segmentation=data/PK_segments_assigned.geojson --segmentation-crs=EPSG:25833 --output-dir=data/output --library filters --lastools-dir=\"C:/LAStools\"\n</pre> !afwizard --dataset=data/PK_last.laz --dataset-crs=EPSG:25833 --segmentation=data/PK_segments_assigned.geojson --segmentation-crs=EPSG:25833 --output-dir=data/output --library filters --lastools-dir=\"C:/LAStools\" In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"workflow_PK.html#study-case-1-punta-kriza-hr","title":"Study case 1: Punta Kri\u017ea, HR\u00b6","text":""},{"location":"workflow_PK.html#about-the-dataset","title":"About the dataset\u00b6","text":"<p>This LiDAR dataset covers an area at the south coast of Cres Island in Croatia, to the west of Punta Kri\u017ea. It has a point density of approximately 9 pts/m$^2$.</p>"},{"location":"workflow_PK.html#1-import-afwizard-set-parameters-and-load-your-dataset","title":"1. Import <code>afwizard</code>, set parameters and load your dataset\u00b6","text":"<p>First, we import the <code>afwizard</code> library:</p>"},{"location":"workflow_PK.html#2-restricting-datasets","title":"2. Restricting datasets\u00b6","text":""},{"location":"workflow_PK.html#3-creating-filter-pipelines","title":"3. Creating filter pipelines\u00b6","text":""},{"location":"workflow_PK.html#4-mapping-segmentations-to-filter-pipelines","title":"4. Mapping segmentations to filter pipelines\u00b6","text":""},{"location":"workflow_PK.html#5-adaptive-filtering-by-running-afwizard","title":"5. Adaptive filtering by running AFwizard\u00b6","text":""},{"location":"workflow_StA.html","title":"Study site 2","text":"In\u00a0[\u00a0]: Copied! <pre>import afwizard as af\n</pre> import afwizard as af <p>Now, we have to set the LAStools directory to the path where we installed LAStools. This may be a different location on your computer, so you will have to provide the correct path:</p> In\u00a0[\u00a0]: Copied! <pre>af.set_lastools_directory(\"C:/LAStools\")\n</pre> af.set_lastools_directory(\"C:/LAStools\") <p>The next steps are to create the directory \"filters\", where we will later save our developed filter pipelines. After that, we set the directory where the input data is located and where the output data will be written. In case, the directory is not existing, it will be created.</p> In\u00a0[\u00a0]: Copied! <pre>af.set_data_directory(\"filters\", create_dir=True)\n</pre> af.set_data_directory(\"filters\", create_dir=True) In\u00a0[\u00a0]: Copied! <pre>af.set_data_directory(\"data\", create_dir=True)\n</pre> af.set_data_directory(\"data\", create_dir=True) <p>Now we can load our first dataset by file name and additionally provide the spatial reference system. Make sure that the data are copied to your data directory specified just before.</p> In\u00a0[\u00a0]: Copied! <pre>ds = af.DataSet(filename=\"StA_last.laz\", spatial_reference=\"EPSG:31256\")\n</pre> ds = af.DataSet(filename=\"StA_last.laz\", spatial_reference=\"EPSG:31256\") <p>We remove any existing classification from the dataset.</p> In\u00a0[\u00a0]: Copied! <pre>ds = af.remove_classification(ds)\n</pre> ds = af.remove_classification(ds) <p>In the case of this dataset, there is only one segment. Still, we have to load a GeoJSON file containing a pre-prepared segmentation (in this case with just one segment) of the LiDAR tile. In case you want to produce your own segmentation, you can use e.g. QGIS: create a new shapefile layer, draw the segments (the shapes must not overlap and there must not be areas in your dataset not covered by a segment) and export the layer as GeoJSON.</p> In\u00a0[\u00a0]: Copied! <pre>segmentation = af.load_segmentation(\n    \"StA_segment.geojson\", spatial_reference=\"EPSG:31256\"\n)\n</pre> segmentation = af.load_segmentation(     \"StA_segment.geojson\", spatial_reference=\"EPSG:31256\" ) <p>Since the segments in the segmentation may cover large areas and contain many points, we can sample our segments using the <code>restrict</code> method of <code>afwizard</code>. This will make the process of creating filter pipelines much faster! The aim is to select characteristic subareas running the following command. The command will open a GUI showing the segment on a map. If you want to see a draft hillshade version of the DTM, click on \"Visualize\".</p> <p>Click the small polygon on the sidebar on the left to draw a segmentation polygon for an area of interest. When you are done, finish by clicking \"Finalize\". Your restricted dataset is then saved to the variable <code>rds</code>. Save the data by executing the next code cell \"<code>(saved = rds.save(...))</code>\". If you do not draw a polygon, the entire tile will be used in the next steps.</p> In\u00a0[\u00a0]: Copied! <pre>rds = ds.restrict(segmentation_overlay=segmentation)\n</pre> rds = ds.restrict(segmentation_overlay=segmentation) In\u00a0[\u00a0]: Copied! <pre>saved = rds.save(\"data/sample_StA.las\", overwrite=True)\n</pre> saved = rds.save(\"data/sample_StA.las\", overwrite=True) <p>Now we can create a filter pipelines for the restricted dataset we created before. This is done using the interactive <code>pipeline_tuning</code> function. Here, you can select from different outlier filtering and ground filtering algorithms and combine them in a sequential filter pipeline. You can preview the result of different versions of your pipelines and delete filtering steps if it turns out they are not needed or need different settings.</p> In\u00a0[\u00a0]: Copied! <pre>sampledataset1 = af.DataSet(filename=\"data/sample_StA.las\", spatial_reference=\"EPSG:31256\")\n</pre> sampledataset1 = af.DataSet(filename=\"data/sample_StA.las\", spatial_reference=\"EPSG:31256\") <p>The following command will open the GUI for creating a filter pipeline. In the centre, the point cloud of the spatial sample is visualized as hillshade, slope or a combination of both. Visualization settings can be tuned using the fields in the right column.</p> <p>In the center, a tab (#0) with an image is displayed showing the unclassified data as hillshade.</p> <p>In the left column, a filter can be added to the pipeline. Click on \"Pipeline stages\" and then on \"+ Add entry\" and select the filter algorithm of your choice (here: lasground_new (LASTools)). Finally, you can set the parameters (offset, spike, step). Here, we let them at their defaut values. (0, 0.5, 1). Clicking \"Preview\" button on top of the right column will trigger the filtering of the sample using the current filter and parameter strings and display the result as a new window in tab \"#1\" in the centre column (with the preset hillshade at 45\u00b0 altitude and 0.2 m resolution).</p> In\u00a0[\u00a0]: Copied! <pre>pipeline1 = af.pipeline_tuning(sampledataset1)\n</pre> pipeline1 = af.pipeline_tuning(sampledataset1) In\u00a0[\u00a0]: Copied! <pre>af.set_data_directory(\"filters\", create_dir=True)\naf.save_filter(pipeline1, \"filters/StA_woodland.json\")\n</pre> af.set_data_directory(\"filters\", create_dir=True) af.save_filter(pipeline1, \"filters/StA_woodland.json\") <p>Now we map the created filter pipelines to the segmentations.</p> In\u00a0[\u00a0]: Copied! <pre>af.add_filter_library(path=\"filters\", recursive=False)\n</pre> af.add_filter_library(path=\"filters\", recursive=False) <p>Using the selection window below, select the pipeline you created before. Finish the interactive step by clicking \"Finalize\".</p> In\u00a0[\u00a0]: Copied! <pre>pipelines = af.select_pipeline_from_library(\"filters\")\n</pre> pipelines = af.select_pipeline_from_library(\"filters\") <p>In this stage, you select which pipeline to assign to which segment. As we have only one segment, on the top right, you leave the dropdown menu to \"ID\". In the dropdown menu below the segment, select the corresponding filter you created. When you are done with assigning, click \"Finalize\". Then run the next code cell to save the segments together with their assigned filter pipeline.</p> In\u00a0[\u00a0]: Copied! <pre>assigned_segmentation = af.assign_pipeline(\n    ds, segmentation=segmentation, pipelines=pipelines\n)\n</pre> assigned_segmentation = af.assign_pipeline(     ds, segmentation=segmentation, pipelines=pipelines ) In\u00a0[\u00a0]: Copied! <pre>af.set_data_directory(\"data\", create_dir=True)\nassigned_segmentation.save(\"data/StA_segments_assigned.geojson\")\n</pre> af.set_data_directory(\"data\", create_dir=True) assigned_segmentation.save(\"data/StA_segments_assigned.geojson\") <p>Finally, the adaptive filtering has to be calculated. This is done on a command line basis. Therefore, open a new Tab using the \"+\" symbol next to the top of this window and cklick on \"Terminal\".</p> <p>ATTENTION: the directories refer relatively to the directory of the prompt in the terminal!</p> <p>In the example below, the prompt is executed from <code>.../trail-groundfiltering</code>. Filesystem is:</p> <ul> <li><code>.../trail-groundfiltering</code></li> <li><code>.../trail-groundfiltering/data</code></li> <li><code>.../trail-groundfiltering/filters</code></li> </ul> <p>Note:</p> <ul> <li>file <code>StA_last.laz</code> is in directory <code>data</code></li> <li>file <code>StA_segments_assigned.geojson</code> is in directory <code>data</code></li> <li>Directory <code>output</code> will be created in <code>data/output</code></li> <li>filters are stored in <code>filters</code></li> </ul> <pre>afwizard --dataset=data/StA_last.laz --dataset-crs=EPSG:31256 --segmentation=data/StA_segment_assigned.geojson --segmentation-crs=EPSG:31256 --output-dir=data/output --library filters --lastools-dir=\"C:\\LAStools\"\n</pre> In\u00a0[\u00a0]: Copied! <pre>!afwizard --dataset=data/StA_last.laz --dataset-crs=EPSG:31256 --segmentation=data/StA_segments_assigned.geojson --segmentation-crs=EPSG:31256 --output-dir=data/output --library filters --lastools-dir=\"C:/LAStools\"\n</pre> !afwizard --dataset=data/StA_last.laz --dataset-crs=EPSG:31256 --segmentation=data/StA_segments_assigned.geojson --segmentation-crs=EPSG:31256 --output-dir=data/output --library filters --lastools-dir=\"C:/LAStools\" In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"workflow_StA.html#study-case-2-monastery-st-anna-scharfeneck-ruin-at","title":"Study case 2: Monastery St. Anna &amp; Scharfeneck Ruin, AT\u00b6","text":""},{"location":"workflow_StA.html#about-the-dataset","title":"About the dataset\u00b6","text":"<p>This LiDAR dataset covers an area in the nature park Mannersdorf-W\u00fcste in Eastern Austria and includes the monastery St. Anna and the Scharfeneck Ruin. It has a point density of approximately 9 pts/m$^2$.</p>"},{"location":"workflow_StA.html#1-import-afwizard-set-parameters-and-load-your-dataset","title":"1. Import <code>afwizard</code>, set parameters and load your dataset\u00b6","text":"<p>First, we import the afwizard library:</p>"},{"location":"workflow_StA.html#2-restricting-datasets","title":"2. Restricting datasets\u00b6","text":""},{"location":"workflow_StA.html#3-creating-filter-pipelines","title":"3. Creating filter pipelines\u00b6","text":""},{"location":"workflow_StA.html#4-mapping-segmentations-to-filter-pipelines","title":"4. Mapping segmentations to Filter Pipelines\u00b6","text":""},{"location":"workflow_StA.html#5-adaptive-filtering-by-running-afwizard","title":"5. Adaptive filtering by running AFwizard\u00b6","text":""}]}